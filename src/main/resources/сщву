package com.psychology.config;

import com.psychology.ratelimiting.RateLimitInterceptor;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class RateLimitConfig implements WebMvcConfigurer {

    private final RateLimitInterceptor rateLimitInterceptor;

    public RateLimitConfig(RateLimitInterceptor rateLimitInterceptor) {
        this.rateLimitInterceptor = rateLimitInterceptor;
    }

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(rateLimitInterceptor)
                .addPathPatterns("/api/v1/auth/**") // Ограничиваем эндпоинты авторизации
                .addPathPatterns("/api/v1/otp/**")
                .excludePathPatterns("/api/v1/auth/refresh"); // Исключаем refresh
    }
}package com.psychology.config;

 import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.Configuration;
 import org.springframework.data.redis.connection.RedisConnectionFactory;
 import org.springframework.data.redis.core.RedisTemplate;
 import org.springframework.data.redis.serializer.StringRedisSerializer;

 @Configuration
 public class RedisConfig {

     @Bean
     public RedisTemplate<String, String> redisTemplate(RedisConnectionFactory connectionFactory) {
         RedisTemplate<String, String> template = new RedisTemplate<>();
         template.setConnectionFactory(connectionFactory);
         template.setKeySerializer(new StringRedisSerializer());
         template.setValueSerializer(new StringRedisSerializer());
         return template;
     }
 }package com.psychology.config;

  import com.psychology.security.JwtAuthenticationFilter;
  import lombok.RequiredArgsConstructor;
  import org.springframework.context.annotation.Bean;
  import org.springframework.context.annotation.Configuration;
  import org.springframework.security.authentication.AuthenticationManager;
  import org.springframework.security.authentication.AuthenticationProvider;
  import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
  import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
  import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
  import org.springframework.security.config.annotation.web.builders.HttpSecurity;
  import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
  import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
  import org.springframework.security.config.http.SessionCreationPolicy;
  import org.springframework.security.core.userdetails.UserDetailsService;
  import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
  import org.springframework.security.crypto.password.PasswordEncoder;
  import org.springframework.security.web.SecurityFilterChain;
  import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
  import org.springframework.web.cors.CorsConfiguration;
  import org.springframework.web.cors.CorsConfigurationSource;
  import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

  import java.util.Arrays;
  import java.util.List;

  @Configuration
  @EnableWebSecurity
  @EnableMethodSecurity
  @RequiredArgsConstructor
  public class SecurityConfig {

      private final JwtAuthenticationFilter jwtAuthFilter;
      private final UserDetailsService userDetailsService;

      @Bean
      public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
          http
                  .csrf(AbstractHttpConfigurer::disable)
                  .cors(cors -> cors.configurationSource(corsConfigurationSource()))
                  .authorizeHttpRequests(auth -> auth
                          .requestMatchers(
                                  "/api/v1/auth/**",
                                  "/api/v1/invites/validate/**",
                                  "/api/v1/test/**",
                                  "/api/v1/debug/**",
                                  "/ws-chat/**",
                                  "/error",
                                  "/api/v1/files/upload/**"
                          ).permitAll()
                          .requestMatchers("/api/v1/admin/**").hasAuthority("ROLE_ADMIN")
                          .requestMatchers("/api/v1/psychologist/**").hasAuthority("ROLE_PSYCHOLOGIST")
                          .requestMatchers("/api/v1/client/**").hasAuthority("ROLE_CLIENT")
                          .requestMatchers("/api/v1/chat/**").authenticated()
                          .requestMatchers("/api/v1/profile/**").authenticated()
                          .requestMatchers("/api/v1/invites/**").authenticated()
                          .requestMatchers("/api/v1/sessions/**").authenticated()
                          .requestMatchers("/api/v1/journal/**").authenticated()
                          .requestMatchers("/api/v1/recommendations/**").authenticated()
                          .requestMatchers("/api/v1/notifications/**").authenticated()
                          .requestMatchers("/api/v1/dashboard/**").authenticated()
                          .requestMatchers("/api/v1/clients/**").authenticated()
                          .anyRequest().authenticated()
                  )
                  .sessionManagement(session -> session
                          .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                  )
                  .authenticationProvider(authenticationProvider())
                  .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class);

          return http.build();
      }

      @Bean
      public CorsConfigurationSource corsConfigurationSource() {
          CorsConfiguration configuration = new CorsConfiguration();
          configuration.setAllowedOrigins(Arrays.asList("http://localhost:3000", "http://localhost:8080"));
          configuration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "OPTIONS"));
          configuration.setAllowedHeaders(List.of("*"));
          configuration.setAllowCredentials(true);

          UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
          source.registerCorsConfiguration("/**", configuration);
          return source;
      }

      @Bean
      public AuthenticationProvider authenticationProvider() {
          DaoAuthenticationProvider authProvider =
                  new DaoAuthenticationProvider(userDetailsService);
          authProvider.setPasswordEncoder(passwordEncoder());
          return authProvider;
      }

      @Bean
      public PasswordEncoder passwordEncoder() {
          return new BCryptPasswordEncoder();
      }

      @Bean
      public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {
          return config.getAuthenticationManager();
      }
  }package com.psychology.config;

   import org.springframework.context.annotation.Configuration;
   import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
   import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

   @Configuration
   public class WebConfig implements WebMvcConfigurer {

       @Override
       public void addResourceHandlers(ResourceHandlerRegistry registry) {
           registry.addResourceHandler("/uploads/**")
                   .addResourceLocations("file:uploads/");
       }
   }package com.psychology.config;

    import com.psychology.security.JwtTokenProvider;
    import com.psychology.repository.UserRepository;
    import lombok.RequiredArgsConstructor;
    import lombok.extern.slf4j.Slf4j;
    import org.springframework.context.annotation.Configuration;
    import org.springframework.core.Ordered;
    import org.springframework.core.annotation.Order;
    import org.springframework.messaging.Message;
    import org.springframework.messaging.MessageChannel;
    import org.springframework.messaging.simp.config.ChannelRegistration;
    import org.springframework.messaging.simp.config.MessageBrokerRegistry;
    import org.springframework.messaging.simp.stomp.StompCommand;
    import org.springframework.messaging.simp.stomp.StompHeaderAccessor;
    import org.springframework.messaging.support.ChannelInterceptor;
    import org.springframework.messaging.support.MessageHeaderAccessor;
    import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
    import org.springframework.security.core.Authentication;
    import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;
    import org.springframework.web.socket.config.annotation.StompEndpointRegistry;
    import org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurer;

    import java.util.List;

    @Configuration
    @EnableWebSocketMessageBroker
    @Order(Ordered.HIGHEST_PRECEDENCE + 99)
    @RequiredArgsConstructor
    @Slf4j
    public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

        private final JwtTokenProvider jwtTokenProvider;
        private final UserRepository userRepository;

        @Override
        public void configureMessageBroker(MessageBrokerRegistry config) {
            config.enableSimpleBroker("/topic", "/queue", "/user");
            config.setApplicationDestinationPrefixes("/app");
            config.setUserDestinationPrefix("/user");
        }

        @Override
        public void registerStompEndpoints(StompEndpointRegistry registry) {
            registry.addEndpoint("/ws-chat")
                    .setAllowedOriginPatterns("http://localhost:3000", "http://localhost:8080")
                    .withSockJS();

            registry.addEndpoint("/ws-chat")
                    .setAllowedOriginPatterns("http://localhost:3000", "http://localhost:8080");
        }

        @Override
        public void configureClientInboundChannel(ChannelRegistration registration) {
            registration.interceptors(new ChannelInterceptor() {
                @Override
                public Message<?> preSend(Message<?> message, MessageChannel channel) {
                    StompHeaderAccessor accessor = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class);

                    if (accessor != null && StompCommand.CONNECT.equals(accessor.getCommand())) {
                        List<String> authorization = accessor.getNativeHeader("Authorization");

                        if (authorization != null && !authorization.isEmpty()) {
                            String token = authorization.get(0);

                            if (token != null && token.startsWith("Bearer ")) {
                                token = token.substring(7);

                                try {
                                    if (jwtTokenProvider.validateToken(token)) {
                                        String phone = jwtTokenProvider.extractUsername(token);

                                        var user = userRepository.findByPhone(phone)
                                                .orElseThrow(() -> new RuntimeException("User not found"));

                                        Authentication authentication = new UsernamePasswordAuthenticationToken(
                                                user, null, user.getAuthorities()
                                        );
                                        accessor.setUser(authentication);

                                        log.info("WebSocket authenticated user: {}", phone);
                                    } else {
                                        log.warn("Invalid WebSocket token");
                                        return null;
                                    }
                                } catch (Exception e) {
                                    log.error("Error validating WebSocket token: {}", e.getMessage());
                                    return null;
                                }
                            } else {
                                log.warn("No Bearer token in WebSocket headers");
                                return null;
                            }
                        } else {
                            log.warn("No Authorization header in WebSocket connection");
                            return null;
                        }
                    }
                    return message;
                }
            });
        }

        @Override
        public void configureWebSocketTransport(org.springframework.web.socket.config.annotation.WebSocketTransportRegistration registration) {
            registration.setMessageSizeLimit(5 * 1024 * 1024); // 5MB
            registration.setSendTimeLimit(20 * 1000); // 20 seconds
            registration.setSendBufferSizeLimit(5 * 1024 * 1024); // 5MB
        }
    }package com.psychology.controller;

     import com.psychology.model.entity.Psychologist;
     import com.psychology.service.AdminService;
     import lombok.Data;
     import lombok.RequiredArgsConstructor;
     import org.springframework.http.HttpStatus;
     import org.springframework.http.ResponseEntity;
     import org.springframework.security.access.prepost.PreAuthorize;
     import org.springframework.web.bind.annotation.*;

     import java.time.LocalDateTime;
     import java.util.List;

     @RestController
     @RequestMapping("/api/v1/admin")
     @RequiredArgsConstructor
     @PreAuthorize("hasRole('ADMIN')")
     public class AdminController {

         private final AdminService adminService;

         // Получить список психологов на верификацию
         @GetMapping("/psychologists/pending")
         public ResponseEntity<List<Psychologist>> getPendingPsychologists() {
             List<Psychologist> pendingPsychologists = adminService.getPendingPsychologists();
             return ResponseEntity.ok(pendingPsychologists);
         }

         // Получить список всех психологов
         @GetMapping("/psychologists")
         public ResponseEntity<List<Psychologist>> getAllPsychologists() {
             List<Psychologist> psychologists = adminService.getAllPsychologists();
             return ResponseEntity.ok(psychologists);
         }

         // Верифицировать психолога
         @PostMapping("/psychologists/{psychologistId}/verify")
         public ResponseEntity<?> verifyPsychologist(@PathVariable Long psychologistId) {
             try {
                 Psychologist verified = adminService.verifyPsychologist(psychologistId);
                 return ResponseEntity.ok(verified);
             } catch (RuntimeException e) {
                 return ResponseEntity.status(HttpStatus.NOT_FOUND)
                         .body(new ApiResponse(e.getMessage()));
             }
         }

         // Отклонить верификацию психолога
         @PostMapping("/psychologists/{psychologistId}/reject")
         public ResponseEntity<?> rejectPsychologist(@PathVariable Long psychologistId,
                                                     @RequestBody RejectRequest request) {
             try {
                 adminService.rejectPsychologist(psychologistId, request.getReason());
                 return ResponseEntity.ok(new ApiResponse("Psychologist rejected successfully"));
             } catch (RuntimeException e) {
                 return ResponseEntity.status(HttpStatus.NOT_FOUND)
                         .body(new ApiResponse(e.getMessage()));
             }
         }

         // Получить статистику
         @GetMapping("/stats")
         public ResponseEntity<AdminStats> getStats() {
             AdminStats stats = adminService.getAdminStats();
             return ResponseEntity.ok(stats);
         }

         @Data
         public static class RejectRequest {
             private String reason;
         }

         @Data
         public static class ApiResponse {
             private String message;
             private LocalDateTime timestamp;

             public ApiResponse(String message) {
                 this.message = message;
                 this.timestamp = LocalDateTime.now();
             }
         }

         @Data
         public static class AdminStats {
             private long totalPsychologists;
             private long pendingPsychologists;
             private long verifiedPsychologists;
             private long totalClients;
             private long activeSessionsToday;
         }
     }package com.psychology.controller;

      import com.psychology.dto.AuthDTO.*;
      import com.psychology.service.AuthService;
      import com.psychology.service.OTPService;
      import jakarta.servlet.http.Cookie;
      import jakarta.servlet.http.HttpServletResponse;
      import jakarta.validation.Valid;
      import lombok.RequiredArgsConstructor;
      import org.springframework.http.HttpStatus;
      import org.springframework.http.ResponseEntity;
      import org.springframework.web.bind.annotation.*;

      @RestController
      @RequestMapping("/api/v1/auth")
      @RequiredArgsConstructor
      public class AuthController {
          private final AuthService authService;
          private final OTPService otpService;

          @PostMapping("/send-otp")
          public ResponseEntity<ApiResponse> sendOTP(@Valid @RequestBody PhoneRequest request) {
              try {
                  String otp = otpService.generateOTP(request.getPhone());
                  return ResponseEntity.ok(new ApiResponse("OTP sent successfully"));
              } catch (RuntimeException e) {
                  return ResponseEntity.status(HttpStatus.TOO_MANY_REQUESTS)
                          .body(new ApiResponse(e.getMessage()));
              }
          }

          @PostMapping("/verify-otp")
          public ResponseEntity<?> verifyOTP(@Valid @RequestBody VerifyOtpRequest request) {
              try {
                  AuthResponse response = authService.verifyOTPAndAuthenticate(request);
                  return ResponseEntity.ok(response);
              } catch (RuntimeException e) {
                  return ResponseEntity.status(HttpStatus.UNAUTHORIZED)
                          .body(new ApiResponse(e.getMessage()));
              }
          }

          @PostMapping("/psychologist/register")
          public ResponseEntity<?> registerPsychologist(
                  @Valid @RequestBody PsychologistRegisterRequest request) {
              try {
                  // Проверяем OTP перед регистрацией
                  if (!otpService.verifyOTP(request.getPhone(), request.getOtp())) {
                      return ResponseEntity.status(HttpStatus.UNAUTHORIZED)
                              .body(new ApiResponse("Invalid OTP"));
                  }

                  AuthResponse response = authService.registerPsychologist(request);
                  return ResponseEntity.status(HttpStatus.CREATED).body(response);
              } catch (RuntimeException e) {
                  return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                          .body(new ApiResponse(e.getMessage()));
              }
          }

          @PostMapping("/client/register")
          public ResponseEntity<?> registerClient(
                  @Valid @RequestBody ClientRegisterRequest request,
                  @RequestParam("inviteToken") String inviteToken,
                  HttpServletResponse httpServletResponse) {
              try {
                  // Проверяем OTP перед регистрацией
                  if (!otpService.verifyOTP(request.getPhone(), request.getOtp())) {
                      return ResponseEntity.status(HttpStatus.UNAUTHORIZED)
                              .body(new ApiResponse("Invalid OTP"));
                  }

                  AuthResponse response = authService.registerClient(request, inviteToken);

                  return ResponseEntity.status(HttpStatus.CREATED).body(response);
              } catch (RuntimeException e) {
                  return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                          .body(new ApiResponse(e.getMessage()));
              }
          }

          @PostMapping("/refresh")
          public ResponseEntity<?> refreshToken(@CookieValue(value = "refreshToken", required = false) String refreshToken) {
              if (refreshToken == null) {
                  return ResponseEntity.status(HttpStatus.UNAUTHORIZED)
                          .body(new ApiResponse("Refresh token is missing"));
              }

              try {
                  AuthResponse response = authService.refreshToken(refreshToken);
                  return ResponseEntity.ok(response);
              } catch (RuntimeException e) {
                  return ResponseEntity.status(HttpStatus.UNAUTHORIZED)
                          .body(new ApiResponse(e.getMessage()));
              }
          }

          @PostMapping("/logout")
          public ResponseEntity<ApiResponse> logout(
                  @RequestHeader(value = "Authorization", required = false) String authHeader,
                  @CookieValue(value = "refreshToken", required = false) String refreshToken,
                  HttpServletResponse response) {

              if (authHeader != null && authHeader.startsWith("Bearer ")) {
                  String accessToken = authHeader.substring(7);
                  authService.logout(accessToken, refreshToken);
              }

              // Удаляем refresh token cookie
              Cookie cookie = new Cookie("refreshToken", null);
              cookie.setHttpOnly(true);
              cookie.setSecure(false);
              cookie.setPath("/api/v1/auth/refresh");
              cookie.setMaxAge(0);
              response.addCookie(cookie);

              return ResponseEntity.ok(new ApiResponse("Logged out successfully"));
          }
      }package com.psychology.controller;

       import com.psychology.dto.ChatDTO;
       import com.psychology.model.entity.User;
       import com.psychology.service.ChatService;
       import com.psychology.service.NotificationService;
       import lombok.AllArgsConstructor;
       import lombok.Data;
       import lombok.RequiredArgsConstructor;
       import lombok.extern.slf4j.Slf4j;
       import org.springframework.http.HttpStatus;
       import org.springframework.http.ResponseEntity;
       import org.springframework.messaging.simp.SimpMessagingTemplate;
       import org.springframework.security.core.annotation.AuthenticationPrincipal;
       import org.springframework.web.bind.annotation.*;

       import java.time.LocalDateTime;
       import java.util.List;

       @RestController
       @RequestMapping("/api/v1/chat")
       @RequiredArgsConstructor
       @Slf4j
       public class ChatController {

           private final ChatService chatService;
           private final SimpMessagingTemplate messagingTemplate;
           private final NotificationService notificationService;

           @PostMapping("/send")
           public ResponseEntity<?> sendMessage(
                   @AuthenticationPrincipal User sender,
                   @RequestBody ChatDTO.SendMessageRequest request) {
               try {
                   ChatDTO.MessageResponse response = chatService.sendMessage(sender, request);

                   // Отправляем уведомление через NotificationService
                   notificationService.sendNewMessageNotification(response);

                   return ResponseEntity.ok(response);
               } catch (Exception e) {
                   return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                           .body(new ApiResponse(e.getMessage()));
               }
           }

           @GetMapping("/conversation/{userId}")
           public ResponseEntity<?> getConversation(
                   @AuthenticationPrincipal User currentUser,
                   @PathVariable Long userId) {
               try {
                   List<ChatDTO.MessageResponse> conversation =
                           chatService.getConversation(currentUser, userId);
                   return ResponseEntity.ok(conversation);
               } catch (Exception e) {
                   return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                           .body(new ApiResponse(e.getMessage()));
               }
           }

           @GetMapping("/recent")
           public ResponseEntity<?> getRecentMessages(
                   @AuthenticationPrincipal User user,
                   @RequestParam(required = false) String since) {
               try {
                   LocalDateTime sinceTime = since != null ?
                           LocalDateTime.parse(since) : LocalDateTime.now().minusDays(7);

                   List<ChatDTO.MessageResponse> messages =
                           chatService.getRecentMessages(user, sinceTime);
                   return ResponseEntity.ok(messages);
               } catch (Exception e) {
                   return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                           .body(new ApiResponse(e.getMessage()));
               }
           }

           @PostMapping("/read/{messageId}")
           public ResponseEntity<?> markAsRead(
                   @AuthenticationPrincipal User user,
                   @PathVariable Long messageId) {
               try {
                   chatService.markAsRead(user, messageId);
                   return ResponseEntity.ok(new ApiResponse("Message marked as read"));
               } catch (Exception e) {
                   return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                           .body(new ApiResponse(e.getMessage()));
               }
           }

           @GetMapping("/unread/count")
           public ResponseEntity<?> getUnreadCount(@AuthenticationPrincipal User user) {
               try {
                   Long count = chatService.getUnreadCount(user);
                   // Создаем ответ вручную
                   var response = new ChatDTO.UnreadCountResponse();
                   response.setUnreadCount(count);
                   return ResponseEntity.ok(response);
               } catch (Exception e) {
                   return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                           .body(new ApiResponse(e.getMessage()));
               }
           }

           @GetMapping("/unread")
           public ResponseEntity<?> getUnreadMessages(@AuthenticationPrincipal User user) {
               try {
                   List<ChatDTO.MessageResponse> messages = chatService.getUnreadMessages(user);
                   return ResponseEntity.ok(messages);
               } catch (Exception e) {
                   return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                           .body(new ApiResponse(e.getMessage()));
               }
           }

           // УДАЛЯЕМ WebSocket методы, они теперь в WebSocketChatController

           @Data
           @AllArgsConstructor
           public static class ApiResponse {
               private String message;
               private LocalDateTime timestamp;

               public ApiResponse(String message) {
                   this.message = message;
                   this.timestamp = LocalDateTime.now();
               }
           }
       }package com.psychology.controller;

        import com.psychology.dto.ClientDTO;
        import com.psychology.model.entity.Client;
        import com.psychology.model.entity.Psychologist;
        import com.psychology.service.ClientManagementService;
        import lombok.Data;
        import lombok.RequiredArgsConstructor;
        import org.springframework.format.annotation.DateTimeFormat;
        import org.springframework.http.HttpStatus;
        import org.springframework.http.ResponseEntity;
        import org.springframework.security.access.prepost.PreAuthorize;
        import org.springframework.security.core.annotation.AuthenticationPrincipal;
        import org.springframework.web.bind.annotation.*;

        import java.time.LocalDateTime;
        import java.util.List;
        import java.util.stream.Collectors;

        @RestController
        @RequestMapping("/api/v1/clients")
        @RequiredArgsConstructor
        public class ClientManagementController {

            private final ClientManagementService clientManagementService;

            @GetMapping
            @PreAuthorize("hasRole('PSYCHOLOGIST')")
            public ResponseEntity<List<ClientDTO>> getAllClients(@AuthenticationPrincipal Psychologist psychologist) {
                List<Client> clients = clientManagementService.getAllClients(psychologist);
                List<ClientDTO> dtos = clients.stream()
                        .map(c -> {
                            ClientDTO dto = new ClientDTO();
                            dto.setId(c.getId());
                            dto.setFullName(c.getFullName());
                            dto.setAge(c.getAge());
                            dto.setPhone(c.getPhone());
                            // Не включаем psychologist или включаем только ID
                            return dto;
                        })
                        .collect(Collectors.toList());
                return ResponseEntity.ok(dtos);
            }

            // Получить клиента по ID
            @GetMapping("/{clientId}")
            @PreAuthorize("hasRole('PSYCHOLOGIST')")
            public ResponseEntity<?> getClient(
                    @AuthenticationPrincipal Psychologist psychologist,
                    @PathVariable Long clientId) {
                try {
                    Client client = clientManagementService.getClient(psychologist, clientId);
                    return ResponseEntity.ok(client);
                } catch (RuntimeException e) {
                    return ResponseEntity.status(HttpStatus.FORBIDDEN)
                            .body(new ApiResponse(e.getMessage()));
                }
            }

            // Поиск клиентов
            @GetMapping("/search")
            @PreAuthorize("hasRole('PSYCHOLOGIST')")
            public ResponseEntity<List<Client>> searchClients(
                    @AuthenticationPrincipal Psychologist psychologist,
                    @RequestParam(required = false) String query) {
                List<Client> clients = clientManagementService.searchClients(psychologist, query);
                return ResponseEntity.ok(clients);
            }

            // Получить статистику по клиенту
            @GetMapping("/{clientId}/stats")
            @PreAuthorize("hasRole('PSYCHOLOGIST')")
            public ResponseEntity<?> getClientStats(
                    @AuthenticationPrincipal Psychologist psychologist,
                    @PathVariable Long clientId,
                    @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime from,
                    @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime to) {
                try {
                    ClientStats stats = clientManagementService.getClientStats(psychologist, clientId, from, to);
                    return ResponseEntity.ok(stats);
                } catch (RuntimeException e) {
                    return ResponseEntity.status(HttpStatus.FORBIDDEN)
                            .body(new ApiResponse(e.getMessage()));
                }
            }

            // Получить активность клиента
            @GetMapping("/{clientId}/activity")
            @PreAuthorize("hasRole('PSYCHOLOGIST')")
            public ResponseEntity<?> getClientActivity(
                    @AuthenticationPrincipal Psychologist psychologist,
                    @PathVariable Long clientId,
                    @RequestParam(defaultValue = "30") int days) {
                try {
                    ClientActivity activity = clientManagementService.getClientActivity(psychologist, clientId, days);
                    return ResponseEntity.ok(activity);
                } catch (RuntimeException e) {
                    return ResponseEntity.status(HttpStatus.FORBIDDEN)
                            .body(new ApiResponse(e.getMessage()));
                }
            }

            @Data
            public static class ApiResponse {
                private String message;
                private LocalDateTime timestamp;

                public ApiResponse(String message) {
                    this.message = message;
                    this.timestamp = LocalDateTime.now();
                }
            }

            @Data
            public static class ClientStats {
                private long totalSessions;
                private long completedSessions;
                private long cancelledSessions;
                private long journalEntries;
                private long activeRecommendations;
                private long completedRecommendations;
                private double attendanceRate; // процент посещенных сеансов
            }

            @Data
            public static class ClientActivity {
                private List<SessionActivity> recentSessions;
                private List<JournalActivity> recentJournalEntries;
                private List<RecommendationActivity> recentRecommendations;
                private MessageActivity messageActivity;
            }

            @Data
            public static class SessionActivity {
                private LocalDateTime date;
                private String status;
                private String description;
            }

            @Data
            public static class JournalActivity {
                private LocalDateTime date;
                private String mood;
                private int entryLength;
            }

            @Data
            public static class RecommendationActivity {
                private LocalDateTime date;
                private String title;
                private boolean completed;
            }

            @Data
            public static class MessageActivity {
                private long totalMessages;
                private long unreadMessages;
                private LocalDateTime lastMessageDate;
            }
        }package com.psychology.controller;

         import com.psychology.model.entity.Client;
         import com.psychology.model.entity.Psychologist;
         import com.psychology.model.entity.Session;
         import com.psychology.service.DashboardService;
         import com.psychology.service.NotificationService;
         import lombok.Data;
         import lombok.RequiredArgsConstructor;
         import org.springframework.format.annotation.DateTimeFormat;
         import org.springframework.http.ResponseEntity;
         import org.springframework.security.access.prepost.PreAuthorize;
         import org.springframework.security.core.annotation.AuthenticationPrincipal;
         import org.springframework.web.bind.annotation.*;

         import java.time.LocalDate;
         import java.time.LocalDateTime;
         import java.util.List;

         @RestController
         @RequestMapping("/api/v1/dashboard")
         @RequiredArgsConstructor
         public class DashboardController {

             private final DashboardService dashboardService;

             // Дашборд для психолога
             @GetMapping("/psychologist")
             @PreAuthorize("hasRole('PSYCHOLOGIST')")
             public ResponseEntity<PsychologistDashboard> getPsychologistDashboard(
                     @AuthenticationPrincipal Psychologist psychologist) {
                 PsychologistDashboard dashboard = dashboardService.getPsychologistDashboard(psychologist);
                 return ResponseEntity.ok(dashboard);
             }

             // Дашборд для клиента
             @GetMapping("/client")
             @PreAuthorize("hasRole('CLIENT')")
             public ResponseEntity<ClientDashboard> getClientDashboard(
                     @AuthenticationPrincipal Client client) {
                 ClientDashboard dashboard = dashboardService.getClientDashboard(client);
                 return ResponseEntity.ok(dashboard);
             }

             // Статистика за период (для психолога)
             @GetMapping("/psychologist/stats")
             @PreAuthorize("hasRole('PSYCHOLOGIST')")
             public ResponseEntity<PsychologistStats> getPsychologistStats(
                     @AuthenticationPrincipal Psychologist psychologist,
                     @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate startDate,
                     @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate endDate) {

                 LocalDateTime start = startDate != null ? startDate.atStartOfDay() : LocalDate.now().minusMonths(1).atStartOfDay();
                 LocalDateTime end = endDate != null ? endDate.atTime(23, 59, 59) : LocalDateTime.now();

                 PsychologistStats stats = dashboardService.getPsychologistStats(psychologist, start, end);
                 return ResponseEntity.ok(stats);
             }

             // Ближайшие сеансы для психолога
             @GetMapping("/psychologist/upcoming-sessions")
             @PreAuthorize("hasRole('PSYCHOLOGIST')")
             public ResponseEntity<List<Session>> getUpcomingSessions(
                     @AuthenticationPrincipal Psychologist psychologist,
                     @RequestParam(defaultValue = "7") int daysAhead) {
                 List<Session> sessions = dashboardService.getUpcomingSessions(psychologist, daysAhead);
                 return ResponseEntity.ok(sessions);
             }

             // Активные клиенты (с сеансами в ближайшие 30 дней)
             @GetMapping("/psychologist/active-clients")
             @PreAuthorize("hasRole('PSYCHOLOGIST')")
             public ResponseEntity<List<Client>> getActiveClients(@AuthenticationPrincipal Psychologist psychologist) {
                 List<Client> clients = dashboardService.getActiveClients(psychologist);
                 return ResponseEntity.ok(clients);
             }

             @Data
             public static class PsychologistDashboard {
                 private long totalClients;
                 private long activeClients; // с сеансами в ближайшие 30 дней
                 private long upcomingSessionsToday;
                 private long upcomingSessionsThisWeek;
                 private long pendingRecommendations; // невыполненные рекомендации
                 private long unreadMessages;
                 private List<Session> nextSessions; // ближайшие 5 сеансов
                 private MonthlyStats monthlyStats;
             }

             @Data
             public static class ClientDashboard {
                 private PsychologistInfo psychologist;
                 private Session nextSession;
                 private long unreadMessages;
                 private long pendingRecommendations; // активные рекомендации
                 private long journalEntriesThisMonth;
                 private List<Session> upcomingSessions; // ближайшие 5 сеансов
                 private List<NotificationService.NotificationDTO> recentNotifications;
             }

             @Data
             public static class PsychologistStats {
                 private long totalSessions;
                 private long completedSessions;
                 private long cancelledSessions;
                 private long newClients;
                 private double averageSessionsPerClient;
                 private List<MonthlySessionCount> monthlySessionCounts;
             }

             @Data
             public static class PsychologistInfo {
                 private Long id;
                 private String fullName;
                 private String specialization;
                 private String photoUrl;
                 private String email;
             }

             @Data
             public static class MonthlyStats {
                 private long sessionsCompleted;
                 private long sessionsScheduled;
                 private long newClients;
                 private double revenue; // если будет система оплаты
             }

             @Data
             public static class MonthlySessionCount {
                 private String month;
                 private long count;
             }
         }package com.psychology.controller;

          import com.psychology.model.entity.Psychologist;
          import com.psychology.model.entity.Invite;
          import com.psychology.repository.PsychologistRepository;
          import com.psychology.repository.InviteRepository;
          import lombok.RequiredArgsConstructor;
          import lombok.extern.slf4j.Slf4j;
          import org.springframework.http.ResponseEntity;
          import org.springframework.web.bind.annotation.*;

          import java.util.List;

          @RestController
          @RequestMapping("/api/v1/debug")  // ✅ Путь начинается с /api/v1/debug
          @RequiredArgsConstructor
          @Slf4j
          public class DebugController {

              private final PsychologistRepository psychologistRepository;
              private final InviteRepository inviteRepository;

              @GetMapping("/psychologists")
              public ResponseEntity<List<Psychologist>> getAllPsychologists() {
                  log.info("Getting all psychologists");
                  List<Psychologist> psychologists = psychologistRepository.findAll();
                  return ResponseEntity.ok(psychologists);
              }

              @GetMapping("/invites")
              public ResponseEntity<List<Invite>> getAllInvites() {
                  log.info("Getting all invites");
                  List<Invite> invites = inviteRepository.findAll();
                  return ResponseEntity.ok(invites);
              }

              @GetMapping("/health")
              public ResponseEntity<String> health() {
                  return ResponseEntity.ok("OK");
              }
          }package com.psychology.controller;

           import com.psychology.service.FileStorageService;
           import lombok.RequiredArgsConstructor;
           import lombok.extern.slf4j.Slf4j;
           import org.springframework.http.MediaType;
           import org.springframework.http.ResponseEntity;
           import org.springframework.security.core.annotation.AuthenticationPrincipal;
           import org.springframework.web.bind.annotation.*;
           import org.springframework.web.multipart.MultipartFile;

           import java.io.IOException;
           import java.time.LocalDateTime;

           @RestController
           @RequestMapping("/api/v1/files")
           @RequiredArgsConstructor
           @Slf4j
           public class FileUploadController {

               private final FileStorageService fileStorageService;

               @PostMapping("/upload")
               public ResponseEntity<?> uploadFile(@AuthenticationPrincipal Object user,
                                                   @RequestParam("file") MultipartFile file) {
                   try {
                       log.info("Uploading file: {} by user {}", file.getOriginalFilename(), user);

                       String fileUrl = fileStorageService.storeFile(file);

                       return ResponseEntity.ok(new FileUploadResponse(
                               fileUrl,
                               file.getOriginalFilename(),
                               file.getContentType(),
                               file.getSize()
                       ));

                   } catch (IOException e) {
                       log.error("Error uploading file: {}", e.getMessage());
                       return ResponseEntity.badRequest()
                               .body(new ApiResponse("Failed to upload file: " + e.getMessage()));
                   } catch (RuntimeException e) {
                       return ResponseEntity.badRequest()
                               .body(new ApiResponse(e.getMessage()));
                   }
               }

               @GetMapping("/download/{filename:.+}")
               public ResponseEntity<byte[]> downloadFile(@PathVariable String filename) {
                   try {
                       byte[] fileContent = fileStorageService.loadFile(filename);

                       return ResponseEntity.ok()
                               .contentType(MediaType.APPLICATION_OCTET_STREAM)
                               .header("Content-Disposition", "attachment; filename=\"" + filename + "\"")
                               .body(fileContent);

                   } catch (IOException e) {
                       return ResponseEntity.notFound().build();
                   }
               }

               @lombok.Data
               public static class FileUploadResponse {
                   private String fileUrl;
                   private String originalName;
                   private String contentType;
                   private long size;
                   private LocalDateTime uploadedAt = LocalDateTime.now();

                   public FileUploadResponse(String fileUrl, String originalName, String contentType, long size) {
                       this.fileUrl = fileUrl;
                       this.originalName = originalName;
                       this.contentType = contentType;
                       this.size = size;
                   }
               }

               @lombok.Data
               public static class ApiResponse {
                   private String message;
                   private LocalDateTime timestamp;

                   public ApiResponse(String message) {
                       this.message = message;
                       this.timestamp = LocalDateTime.now();
                   }
               }
           }package com.psychology.controller;

            import com.psychology.model.entity.Psychologist;
            import com.psychology.repository.PsychologistRepository;
            import com.psychology.service.InviteService;
            import lombok.Data;
            import lombok.RequiredArgsConstructor;
            import lombok.extern.slf4j.Slf4j;
            import org.springframework.http.HttpStatus;
            import org.springframework.http.ResponseEntity;
            import org.springframework.security.access.prepost.PreAuthorize;
            import org.springframework.security.core.annotation.AuthenticationPrincipal;
            import org.springframework.security.core.userdetails.UserDetails;
            import org.springframework.web.bind.annotation.*;

            import java.time.LocalDateTime;
            import java.util.List;

            @RestController
            @RequestMapping("/api/v1/invites")
            @RequiredArgsConstructor
            @Slf4j
            public class InviteController {
                private final InviteService inviteService;
                private final PsychologistRepository psychologistRepository;

                @PostMapping
                @PreAuthorize("hasRole('PSYCHOLOGIST')") // Добавляем проверку роли
                public ResponseEntity<?> createInvite(@AuthenticationPrincipal Object principal) {
                    log.info("=== CREATE INVITE REQUEST ===");

                    try {
                        if (principal == null) {
                            return ResponseEntity.status(HttpStatus.UNAUTHORIZED)
                                    .body(new ApiResponse("Not authenticated"));
                        }

                        Psychologist psychologist;

                        // Обрабатываем разные типы principal
                        if (principal instanceof Psychologist) {
                            psychologist = (Psychologist) principal;
                            log.info("Principal is Psychologist: ID={}", psychologist.getId());
                        } else if (principal instanceof org.springframework.security.core.userdetails.UserDetails) {
                            // Получаем phone из UserDetails
                            String phone = ((org.springframework.security.core.userdetails.UserDetails) principal).getUsername();
                            log.info("Principal is UserDetails, phone: {}", phone);

                            // Ищем психолога по телефону
                            psychologist = psychologistRepository.findByPhone(phone)
                                    .orElseThrow(() -> {
                                        log.error("Psychologist not found with phone: {}", phone);
                                        return new RuntimeException("Psychologist not found");
                                    });
                            log.info("Found psychologist from DB: ID={}", psychologist.getId());
                        } else {
                            log.error("Unknown principal type: {}", principal.getClass().getName());
                            return ResponseEntity.status(HttpStatus.FORBIDDEN)
                                    .body(new ApiResponse("Invalid user type"));
                        }

                        // Проверяем верификацию психолога
                        if (!psychologist.isVerified()) {
                            log.warn("Psychologist {} is not verified", psychologist.getId());
                            return ResponseEntity.status(HttpStatus.FORBIDDEN)
                                    .body(new ApiResponse("Psychologist account is not verified yet. Please wait for administrator verification."));
                        }

                        String token = inviteService.createInvite(psychologist);
                        String inviteLink = "http://localhost:3000/register?invite=" + token;

                        log.info("Invite created successfully for psychologist ID: {}", psychologist.getId());

                        return ResponseEntity.ok(new InviteResponse(token, inviteLink));

                    } catch (Exception e) {
                        log.error("Error creating invite: ", e);
                        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                                .body(new ApiResponse("Failed to create invite: " + e.getMessage()));
                    }
                }

                @GetMapping
                @PreAuthorize("hasRole('PSYCHOLOGIST')")
                public ResponseEntity<?> getInvites(@AuthenticationPrincipal Object principal) {
                    try {
                        Psychologist psychologist = extractPsychologist(principal);
                        if (psychologist == null) {
                            return ResponseEntity.status(HttpStatus.UNAUTHORIZED)
                                    .body(new ApiResponse("Psychologist not found"));
                        }

                        List<InviteDTO> invites = inviteService.getInvitesByPsychologist(psychologist.getId());
                        return ResponseEntity.ok(invites);
                    } catch (Exception e) {
                        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                                .body(new ApiResponse("Failed to get invites: " + e.getMessage()));
                    }
                }

                @GetMapping("/validate/{token}")
                public ResponseEntity<?> validateInvite(@PathVariable String token) {
                    log.info("Validating invite token: {}", token);
                    try {
                        InviteValidationResponse response = inviteService.validateInvite(token);
                        return ResponseEntity.ok(response);
                    } catch (Exception e) {
                        log.error("Invalid invite token: {}", token, e);
                        return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                                .body(new ApiResponse("Invalid invite: " + e.getMessage()));
                    }
                }
                private Psychologist extractPsychologist(Object principal) {
                    if (principal instanceof Psychologist) {
                        return (Psychologist) principal;
                    } else if (principal instanceof org.springframework.security.core.userdetails.UserDetails) {
                        String phone = ((org.springframework.security.core.userdetails.UserDetails) principal).getUsername();
                        return psychologistRepository.findByPhone(phone).orElse(null);
                    }
                    return null;
                }

                // DTO классы
                @Data
                public static class InviteResponse {
                    private String token;
                    private String inviteLink;

                    public InviteResponse(String token, String inviteLink) {
                        this.token = token;
                        this.inviteLink = inviteLink;
                    }
                }

                @Data
                public static class InviteDTO {
                    private String token;
                    private String createdAt;
                    private String expiresAt;
                    private boolean used;

                    public InviteDTO(String token, String createdAt, String expiresAt, boolean used) {
                        this.token = token;
                        this.createdAt = createdAt;
                        this.expiresAt = expiresAt;
                        this.used = used;
                    }
                }

                @Data
                public static class InviteValidationResponse {
                    private boolean valid;
                    private String psychologistName;
                    private String expiresAt;

                    public InviteValidationResponse(boolean valid, String psychologistName, String expiresAt) {
                        this.valid = valid;
                        this.psychologistName = psychologistName;
                        this.expiresAt = expiresAt;
                    }
                }

                @Data
                public static class ApiResponse {
                    private String message;
                    private LocalDateTime timestamp;

                    public ApiResponse(String message) {
                        this.message = message;
                        this.timestamp = LocalDateTime.now();
                    }
                }
            }package com.psychology.controller;

             import com.psychology.model.entity.Client;
             import com.psychology.model.entity.JournalEntry;
             import com.psychology.model.entity.Psychologist;
             import com.psychology.service.JournalService;
             import lombok.Data;
             import lombok.RequiredArgsConstructor;
             import org.springframework.http.HttpStatus;
             import org.springframework.http.ResponseEntity;
             import org.springframework.security.access.prepost.PreAuthorize;
             import org.springframework.security.core.annotation.AuthenticationPrincipal;
             import org.springframework.web.bind.annotation.*;

             import java.time.LocalDateTime;
             import java.util.List;

             @RestController
             @RequestMapping("/api/v1/journal")
             @RequiredArgsConstructor
             public class JournalController {

                 private final JournalService journalService;

                 // Клиент создает запись в дневнике
                 @PostMapping
                 @PreAuthorize("hasRole('CLIENT')")
                 public ResponseEntity<?> createEntry(
                         @AuthenticationPrincipal Client client,
                         @RequestBody JournalEntryRequest request) {
                     try {
                         JournalEntry entry = journalService.createEntry(client, request);
                         return ResponseEntity.status(HttpStatus.CREATED).body(entry);
                     } catch (RuntimeException e) {
                         return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                                 .body(new ApiResponse(e.getMessage()));
                     }
                 }

                 // Клиент получает свои записи
                 @GetMapping
                 @PreAuthorize("hasRole('CLIENT')")
                 public ResponseEntity<List<JournalEntry>> getMyEntries(
                         @AuthenticationPrincipal Client client,
                         @RequestParam(required = false) Integer page,
                         @RequestParam(required = false) Integer size) {
                     int pageNumber = page != null ? page : 0;
                     int pageSize = size != null ? size : 20;

                     List<JournalEntry> entries = journalService.getClientEntries(client.getId(), pageNumber, pageSize);
                     return ResponseEntity.ok(entries);
                 }

                 // Клиент получает запись по ID
                 @GetMapping("/{entryId}")
                 @PreAuthorize("hasRole('CLIENT')")
                 public ResponseEntity<?> getEntry(
                         @AuthenticationPrincipal Client client,
                         @PathVariable Long entryId) {
                     try {
                         JournalEntry entry = journalService.getClientEntry(client.getId(), entryId);
                         return ResponseEntity.ok(entry);
                     } catch (RuntimeException e) {
                         return ResponseEntity.status(HttpStatus.NOT_FOUND)
                                 .body(new ApiResponse(e.getMessage()));
                     }
                 }

                 // Клиент обновляет запись
                 @PutMapping("/{entryId}")
                 @PreAuthorize("hasRole('CLIENT')")
                 public ResponseEntity<?> updateEntry(
                         @AuthenticationPrincipal Client client,
                         @PathVariable Long entryId,
                         @RequestBody JournalEntryRequest request) {
                     try {
                         JournalEntry entry = journalService.updateEntry(client.getId(), entryId, request);
                         return ResponseEntity.ok(entry);
                     } catch (RuntimeException e) {
                         return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                                 .body(new ApiResponse(e.getMessage()));
                     }
                 }

                 // Клиент удаляет запись
                 @DeleteMapping("/{entryId}")
                 @PreAuthorize("hasRole('CLIENT')")
                 public ResponseEntity<?> deleteEntry(
                         @AuthenticationPrincipal Client client,
                         @PathVariable Long entryId) {
                     try {
                         journalService.deleteEntry(client.getId(), entryId);
                         return ResponseEntity.ok(new ApiResponse("Entry deleted successfully"));
                     } catch (RuntimeException e) {
                         return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                                 .body(new ApiResponse(e.getMessage()));
                     }
                 }

                 // Психолог получает записи своего клиента
                 @GetMapping("/client/{clientId}")
                 @PreAuthorize("hasRole('PSYCHOLOGIST')")
                 public ResponseEntity<?> getClientEntries(
                         @AuthenticationPrincipal Psychologist psychologist,
                         @PathVariable Long clientId,
                         @RequestParam(required = false) Integer page,
                         @RequestParam(required = false) Integer size) {
                     try {
                         int pageNumber = page != null ? page : 0;
                         int pageSize = size != null ? size : 20;

                         List<JournalEntry> entries = journalService.getClientEntriesForPsychologist(psychologist.getId(), clientId, pageNumber, pageSize);
                         return ResponseEntity.ok(entries);
                     } catch (RuntimeException e) {
                         return ResponseEntity.status(HttpStatus.FORBIDDEN)
                                 .body(new ApiResponse(e.getMessage()));
                     }
                 }

                 // Психолог получает запись клиента по ID
                 @GetMapping("/client/{clientId}/entry/{entryId}")
                 @PreAuthorize("hasRole('PSYCHOLOGIST')")
                 public ResponseEntity<?> getClientEntry(
                         @AuthenticationPrincipal Psychologist psychologist,
                         @PathVariable Long clientId,
                         @PathVariable Long entryId) {
                     try {
                         JournalEntry entry = journalService.getClientEntryForPsychologist(psychologist.getId(), clientId, entryId);
                         return ResponseEntity.ok(entry);
                     } catch (RuntimeException e) {
                         return ResponseEntity.status(HttpStatus.FORBIDDEN)
                                 .body(new ApiResponse(e.getMessage()));
                     }
                 }

                 // Поиск записей по тегам
                 @GetMapping("/search")
                 @PreAuthorize("hasRole('CLIENT')")
                 public ResponseEntity<?> searchEntries(
                         @AuthenticationPrincipal Client client,
                         @RequestParam String tag) {
                     try {
                         List<JournalEntry> entries = journalService.searchEntriesByTag(client.getId(), tag);
                         return ResponseEntity.ok(entries);
                     } catch (RuntimeException e) {
                         return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                                 .body(new ApiResponse(e.getMessage()));
                     }
                 }

                 // Статистика по дневнику
                 @GetMapping("/stats")
                 @PreAuthorize("hasRole('CLIENT')")
                 public ResponseEntity<?> getJournalStats(@AuthenticationPrincipal Client client) {
                     try {
                         JournalStats stats = journalService.getJournalStats(client.getId());
                         return ResponseEntity.ok(stats);
                     } catch (RuntimeException e) {
                         return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                                 .body(new ApiResponse(e.getMessage()));
                     }
                 }

                 @Data
                 public static class JournalEntryRequest {
                     private String content;
                     private String mood;
                     private List<String> tags;
                 }

                 @Data
                 public static class ApiResponse {
                     private String message;
                     private LocalDateTime timestamp;

                     public ApiResponse(String message) {
                         this.message = message;
                         this.timestamp = LocalDateTime.now();
                     }
                 }

                 @Data
                 public static class JournalStats {
                     private long totalEntries;
                     private long entriesThisMonth;
                     private String mostCommonMood;
                     private List<String> mostUsedTags;
                 }
             }package com.psychology.controller;

              import com.psychology.model.entity.User;
              import com.psychology.service.NotificationService;
              import lombok.Data;
              import lombok.RequiredArgsConstructor;
              import org.springframework.http.ResponseEntity;
              import org.springframework.security.core.annotation.AuthenticationPrincipal;
              import org.springframework.web.bind.annotation.*;

              import java.time.LocalDateTime;
              import java.util.List;

              @RestController
              @RequestMapping("/api/v1/notifications")
              @RequiredArgsConstructor
              public class NotificationController {

                  private final NotificationService notificationService;

                  @GetMapping
                  public ResponseEntity<?> getNotifications(
                          @AuthenticationPrincipal User user,
                          @RequestParam(defaultValue = "0") int page,
                          @RequestParam(defaultValue = "20") int size) {
                      List<NotificationService.NotificationDTO> notifications =
                              notificationService.getUserNotifications(user, page, size)
                                      .stream()
                                      .map(notificationService::convertToDTO)
                                      .toList();
                      return ResponseEntity.ok(notifications);
                  }

                  @GetMapping("/unread")
                  public ResponseEntity<?> getUnreadNotifications(@AuthenticationPrincipal User user) {
                      List<NotificationService.NotificationDTO> notifications =
                              notificationService.getUnreadNotifications(user)
                                      .stream()
                                      .map(notificationService::convertToDTO)
                                      .toList();
                      return ResponseEntity.ok(notifications);
                  }

                  @GetMapping("/unread/count")
                  public ResponseEntity<?> getUnreadCount(@AuthenticationPrincipal User user) {
                      long count = notificationService.getUnreadCount(user);
                      return ResponseEntity.ok(new UnreadCountResponse(count));
                  }

                  @PostMapping("/{notificationId}/read")
                  public ResponseEntity<?> markAsRead(
                          @AuthenticationPrincipal User user,
                          @PathVariable Long notificationId) {
                      try {
                          notificationService.markAsRead(notificationId, user);
                          return ResponseEntity.ok(new ApiResponse("Notification marked as read"));
                      } catch (RuntimeException e) {
                          return ResponseEntity.badRequest().body(new ApiResponse(e.getMessage()));
                      }
                  }

                  @PostMapping("/read-all")
                  public ResponseEntity<?> markAllAsRead(@AuthenticationPrincipal User user) {
                      notificationService.markAllAsRead(user);
                      return ResponseEntity.ok(new ApiResponse("All notifications marked as read"));
                  }

                  @DeleteMapping("/{notificationId}")
                  public ResponseEntity<?> deleteNotification(
                          @AuthenticationPrincipal User user,
                          @PathVariable Long notificationId) {
                      try {
                          notificationService.deleteNotification(notificationId, user);
                          return ResponseEntity.ok(new ApiResponse("Notification deleted"));
                      } catch (RuntimeException e) {
                          return ResponseEntity.badRequest().body(new ApiResponse(e.getMessage()));
                      }
                  }

                  @Data
                  public static class UnreadCountResponse {
                      private long unreadCount;

                      public UnreadCountResponse(long unreadCount) {
                          this.unreadCount = unreadCount;
                      }
                  }

                  @Data
                  public static class ApiResponse {
                      private String message;
                      private LocalDateTime timestamp;

                      public ApiResponse(String message) {
                          this.message = message;
                          this.timestamp = LocalDateTime.now();
                      }
                  }
              }package com.psychology.controller;

               import com.psychology.model.entity.Psychologist;
               import com.psychology.model.entity.Client;
               import com.psychology.service.ProfileService;
               import lombok.Data;
               import lombok.RequiredArgsConstructor;
               import org.springframework.http.HttpStatus;
               import org.springframework.http.ResponseEntity;
               import org.springframework.security.core.annotation.AuthenticationPrincipal;
               import org.springframework.web.bind.annotation.*;

               import java.time.LocalDateTime;

               @RestController
               @RequestMapping("/api/v1/profile")
               @RequiredArgsConstructor
               public class ProfileController {

                   private final ProfileService profileService;

                   // Получить профиль текущего пользователя
                   @GetMapping
                   public ResponseEntity<?> getCurrentProfile(@AuthenticationPrincipal Object user) {
                       if (user instanceof Psychologist) {
                           return ResponseEntity.ok(profileService.getPsychologistProfile((Psychologist) user));
                       } else if (user instanceof Client) {
                           return ResponseEntity.ok(profileService.getClientProfile((Client) user));
                       }
                       return ResponseEntity.status(HttpStatus.UNAUTHORIZED)
                               .body(new ApiResponse("User type not recognized"));
                   }

                   // Обновить профиль психолога
                   @PutMapping("/psychologist")
                   public ResponseEntity<?> updatePsychologistProfile(
                           @AuthenticationPrincipal Psychologist psychologist,
                           @RequestBody PsychologistProfileUpdateRequest request) {
                       try {
                           Psychologist updated = profileService.updatePsychologistProfile(psychologist, request);
                           return ResponseEntity.ok(updated);
                       } catch (Exception e) {
                           return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                                   .body(new ApiResponse(e.getMessage()));
                       }
                   }

                   // Обновить профиль клиента
                   @PutMapping("/client")
                   public ResponseEntity<?> updateClientProfile(
                           @AuthenticationPrincipal Client client,
                           @RequestBody ClientProfileUpdateRequest request) {
                       try {
                           Client updated = profileService.updateClientProfile(client, request);
                           return ResponseEntity.ok(updated);
                       } catch (Exception e) {
                           return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                                   .body(new ApiResponse(e.getMessage()));
                       }
                   }

                   // DTO для обновления профиля психолога
                   @Data
                   public static class PsychologistProfileUpdateRequest {
                       private String fullName;
                       private String email;
                       private String education;
                       private String specialization;
                       private String description;
                       private String photoUrl;
                   }

                   // DTO для обновления профиля клиента
                   @Data
                   public static class ClientProfileUpdateRequest {
                       private String fullName;
                       private Integer age;
                       private String photoUrl;
                   }

                   @Data
                   public static class ApiResponse {
                       private String message;
                       private LocalDateTime timestamp;

                       public ApiResponse(String message) {
                           this.message = message;
                           this.timestamp = LocalDateTime.now();
                       }
                   }
               }package com.psychology.controller;

                import com.psychology.model.entity.Psychologist;
                import com.psychology.model.entity.Client;
                import com.psychology.model.entity.Recommendation;
                import com.psychology.service.RecommendationService;
                import lombok.Data;
                import lombok.RequiredArgsConstructor;
                import org.springframework.format.annotation.DateTimeFormat;
                import org.springframework.http.HttpStatus;
                import org.springframework.http.ResponseEntity;
                import org.springframework.security.access.prepost.PreAuthorize;
                import org.springframework.security.core.annotation.AuthenticationPrincipal;
                import org.springframework.web.bind.annotation.*;

                import java.time.LocalDateTime;
                import java.util.List;

                @RestController
                @RequestMapping("/api/v1/recommendations")
                @RequiredArgsConstructor
                public class RecommendationController {

                    private final RecommendationService recommendationService;

                    // Психолог создает рекомендацию для клиента
                    @PostMapping
                    @PreAuthorize("hasRole('PSYCHOLOGIST')")
                    public ResponseEntity<?> createRecommendation(
                            @AuthenticationPrincipal Psychologist psychologist,
                            @RequestBody RecommendationRequest request) {
                        try {
                            Recommendation recommendation = recommendationService.createRecommendation(psychologist, request);
                            return ResponseEntity.status(HttpStatus.CREATED).body(recommendation);
                        } catch (RuntimeException e) {
                            return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                                    .body(new ApiResponse(e.getMessage()));
                        }
                    }

                    // Психолог обновляет рекомендацию
                    @PutMapping("/{recommendationId}")
                    @PreAuthorize("hasRole('PSYCHOLOGIST')")
                    public ResponseEntity<?> updateRecommendation(
                            @AuthenticationPrincipal Psychologist psychologist,
                            @PathVariable Long recommendationId,
                            @RequestBody RecommendationUpdateRequest request) {
                        try {
                            Recommendation recommendation = recommendationService.updateRecommendation(psychologist, recommendationId, request);
                            return ResponseEntity.ok(recommendation);
                        } catch (RuntimeException e) {
                            return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                                    .body(new ApiResponse(e.getMessage()));
                        }
                    }

                    // Психолог помечает рекомендацию как выполненную
                    @PostMapping("/{recommendationId}/complete")
                    @PreAuthorize("hasRole('PSYCHOLOGIST')")
                    public ResponseEntity<?> completeRecommendation(
                            @AuthenticationPrincipal Psychologist psychologist,
                            @PathVariable Long recommendationId) {
                        try {
                            Recommendation recommendation = recommendationService.completeRecommendation(psychologist, recommendationId);
                            return ResponseEntity.ok(recommendation);
                        } catch (RuntimeException e) {
                            return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                                    .body(new ApiResponse(e.getMessage()));
                        }
                    }

                    // Клиент помечает рекомендацию как выполненную
                    @PostMapping("/{recommendationId}/client-complete")
                    @PreAuthorize("hasRole('CLIENT')")
                    public ResponseEntity<?> markAsCompletedByClient(
                            @AuthenticationPrincipal Client client,
                            @PathVariable Long recommendationId) {
                        try {
                            Recommendation recommendation = recommendationService.markAsCompletedByClient(client, recommendationId);
                            return ResponseEntity.ok(recommendation);
                        } catch (RuntimeException e) {
                            return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                                    .body(new ApiResponse(e.getMessage()));
                        }
                    }

                    // Психолог удаляет рекомендацию
                    @DeleteMapping("/{recommendationId}")
                    @PreAuthorize("hasRole('PSYCHOLOGIST')")
                    public ResponseEntity<?> deleteRecommendation(
                            @AuthenticationPrincipal Psychologist psychologist,
                            @PathVariable Long recommendationId) {
                        try {
                            recommendationService.deleteRecommendation(psychologist, recommendationId);
                            return ResponseEntity.ok(new ApiResponse("Recommendation deleted successfully"));
                        } catch (RuntimeException e) {
                            return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                                    .body(new ApiResponse(e.getMessage()));
                        }
                    }

                    // Психолог получает рекомендации для клиента
                    @GetMapping("/client/{clientId}")
                    @PreAuthorize("hasRole('PSYCHOLOGIST')")
                    public ResponseEntity<?> getClientRecommendations(
                            @AuthenticationPrincipal Psychologist psychologist,
                            @PathVariable Long clientId,
                            @RequestParam(required = false) Boolean completed,
                            @RequestParam(required = false) Boolean overdue,
                            @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime from,
                            @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime to) {
                        try {
                            List<Recommendation> recommendations = recommendationService.getClientRecommendations(
                                    psychologist, clientId, completed, overdue, from, to);
                            return ResponseEntity.ok(recommendations);
                        } catch (RuntimeException e) {
                            return ResponseEntity.status(HttpStatus.FORBIDDEN)
                                    .body(new ApiResponse(e.getMessage()));
                        }
                    }

                    // Клиент получает свои рекомендации
                    @GetMapping
                    @PreAuthorize("hasRole('CLIENT')")
                    public ResponseEntity<List<Recommendation>> getMyRecommendations(
                            @AuthenticationPrincipal Client client,
                            @RequestParam(required = false) Boolean completed,
                            @RequestParam(required = false) Boolean overdue,
                            @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime from,
                            @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime to) {
                        List<Recommendation> recommendations = recommendationService.getMyRecommendations(
                                client, completed, overdue, from, to);
                        return ResponseEntity.ok(recommendations);
                    }

                    // Психолог получает все просроченные рекомендации
                    @GetMapping("/overdue")
                    @PreAuthorize("hasRole('PSYCHOLOGIST')")
                    public ResponseEntity<List<Recommendation>> getOverdueRecommendations(
                            @AuthenticationPrincipal Psychologist psychologist) {
                        List<Recommendation> recommendations = recommendationService.getOverdueRecommendations(psychologist);
                        return ResponseEntity.ok(recommendations);
                    }

                    // Статистика по рекомендациям
                    @GetMapping("/stats")
                    @PreAuthorize("hasRole('PSYCHOLOGIST')")
                    public ResponseEntity<RecommendationStats> getRecommendationStats(
                            @AuthenticationPrincipal Psychologist psychologist) {
                        RecommendationStats stats = recommendationService.getRecommendationStats(psychologist);
                        return ResponseEntity.ok(stats);
                    }

                    @Data
                    public static class RecommendationRequest {
                        private Long clientId;
                        private String title;
                        private String content;
                        private LocalDateTime deadline;
                        private Integer priority; // 1-5, где 5 - наивысший
                        private List<String> categories;
                    }

                    @Data
                    public static class RecommendationUpdateRequest {
                        private String title;
                        private String content;
                        private LocalDateTime deadline;
                        private Integer priority;
                        private Boolean completed;
                        private List<String> categories;
                    }

                    @Data
                    public static class ApiResponse {
                        private String message;
                        private LocalDateTime timestamp;

                        public ApiResponse(String message) {
                            this.message = message;
                            this.timestamp = LocalDateTime.now();
                        }
                    }

                    @Data
                    public static class RecommendationStats {
                        private long totalRecommendations;
                        private long completedRecommendations;
                        private long pendingRecommendations;
                        private long overdueRecommendations;
                        private double completionRate;
                    }
                }package com.psychology.controller;

                 import com.psychology.model.entity.Psychologist;
                 import com.psychology.model.entity.Client;
                 import com.psychology.model.entity.Session;
                 import com.psychology.service.SessionService;
                 import lombok.Data;
                 import lombok.RequiredArgsConstructor;
                 import org.springframework.format.annotation.DateTimeFormat;
                 import org.springframework.http.HttpStatus;
                 import org.springframework.http.ResponseEntity;
                 import org.springframework.security.core.annotation.AuthenticationPrincipal;
                 import org.springframework.web.bind.annotation.*;

                 import java.time.LocalDateTime;
                 import java.util.List;

                 @RestController
                 @RequestMapping("/api/v1/sessions")
                 @RequiredArgsConstructor
                 public class SessionController {

                     private final SessionService sessionService;

                     // Психолог создает сеанс
                     @PostMapping
                     public ResponseEntity<?> createSession(
                             @AuthenticationPrincipal Psychologist psychologist,
                             @RequestBody SessionService.SessionRequest request) {
                         try {
                             Session session = sessionService.createSession(psychologist, request);
                             return ResponseEntity.status(HttpStatus.CREATED).body(session);
                         } catch (RuntimeException e) {
                             return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                                     .body(new ApiResponse(e.getMessage()));
                         }
                     }

                     // Психолог обновляет сеанс
                     @PutMapping("/{sessionId}")
                     public ResponseEntity<?> updateSession(
                             @AuthenticationPrincipal Psychologist psychologist,
                             @PathVariable Long sessionId,
                             @RequestBody SessionService.SessionUpdateRequest request) {
                         try {
                             Session session = sessionService.updateSession(sessionId, psychologist, request);
                             return ResponseEntity.ok(session);
                         } catch (RuntimeException e) {
                             return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                                     .body(new ApiResponse(e.getMessage()));
                         }
                     }

                     // Получить сеансы психолога
                     @GetMapping("/psychologist")
                     public ResponseEntity<List<Session>> getPsychologistSessions(
                             @AuthenticationPrincipal Psychologist psychologist,
                             @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime from,
                             @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime to) {
                         List<Session> sessions = sessionService.getPsychologistSessions(psychologist, from, to);
                         return ResponseEntity.ok(sessions);
                     }

                     // Получить сеансы клиента
                     @GetMapping("/client")
                     public ResponseEntity<List<Session>> getClientSessions(
                             @AuthenticationPrincipal Client client,
                             @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime from,
                             @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime to) {
                         List<Session> sessions = sessionService.getClientSessions(client, from, to);
                         return ResponseEntity.ok(sessions);
                     }

                     // Отменить сеанс
                     @PostMapping("/{sessionId}/cancel")
                     public ResponseEntity<?> cancelSession(
                             @AuthenticationPrincipal Object user,
                             @PathVariable Long sessionId) {
                         try {
                             String userType = getUserType(user);
                             Session session = sessionService.cancelSession(sessionId, userType, user);
                             return ResponseEntity.ok(session);
                         } catch (RuntimeException e) {
                             return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                                     .body(new ApiResponse(e.getMessage()));
                         }
                     }

                     private String getUserType(Object user) {
                         if (user instanceof Psychologist) {
                             return "PSYCHOLOGIST";
                         } else if (user instanceof Client) {
                             return "CLIENT";
                         }
                         throw new RuntimeException("Unknown user type");
                     }

                     @Data
                     public static class ApiResponse {
                         private String message;
                         private LocalDateTime timestamp;

                         public ApiResponse(String message) {
                             this.message = message;
                             this.timestamp = LocalDateTime.now();
                         }
                     }
                 }package com.psychology.controller;

                  import org.springframework.web.bind.annotation.GetMapping;
                  import org.springframework.web.bind.annotation.RequestMapping;
                  import org.springframework.web.bind.annotation.RestController;

                  @RestController
                  @RequestMapping("/api/v1/test")
                  public class TestController {

                      @GetMapping("/simple")
                      public String simpleTest() {
                          return "OK";
                      }

                      @GetMapping("/error-test")
                      public String errorTest() {
                          throw new RuntimeException("Test error");
                      }
                  }package com.psychology.dto;

                   import jakarta.validation.constraints.Email;
                   import jakarta.validation.constraints.NotBlank;
                   import jakarta.validation.constraints.NotNull;
                   import jakarta.validation.constraints.Pattern;
                   import lombok.Data;

                   public class AuthDTO {

                       @Data
                       public static class PhoneRequest {
                           @NotBlank(message = "Phone number is required")
                           @Pattern(regexp = "^\\+?[1-9]\\d{1,14}$", message = "Invalid phone number format")
                           private String phone;
                       }

                       @Data
                       public static class VerifyOtpRequest {
                           @NotBlank
                           private String phone;

                           @NotBlank
                           private String otp;
                       }

                       @Data
                       public static class AuthResponse {
                           private String accessToken;
                           private String refreshToken;
                           private Long userId;
                           private String userRole;
                           private String fullName;
                           private String phone;
                       }

                       @Data
                       public static class PsychologistRegisterRequest {
                           @NotBlank
                           private String phone;

                           @NotBlank
                           private String otp;

                           @NotBlank
                           private String fullName;

                           @NotBlank
                           @Email
                           private String email;

                           private String education;
                           private String specialization;
                           private String description;
                           private String photoUrl;
                       }

                       @Data
                       public static class ClientRegisterRequest {
                           @NotBlank
                           private String phone;

                           @NotBlank
                           private String otp;

                           @NotBlank
                           private String fullName;

                           @NotNull
                           private Integer age;

                           private String photoUrl;
                       }

                       @Data
                       public static class RefreshTokenRequest {
                           @NotBlank
                           private String refreshToken;
                       }

                       @Data
                       public static class ApiResponse {
                           private String message;
                           private Object data;

                           public ApiResponse(String message) {
                               this.message = message;
                           }

                           public ApiResponse(String message, Object data) {
                               this.message = message;
                               this.data = data;
                           }
                       }
                   }package com.psychology.dto;

                    import lombok.AllArgsConstructor;
                    import lombok.Builder;
                    import lombok.Data;
                    import lombok.NoArgsConstructor;

                    @Data
                    @Builder
                    @NoArgsConstructor
                    @AllArgsConstructor
                    public class AuthResponse {
                        private String accessToken;
                        private String refreshToken;
                        private Long userId;
                        private String userRole;
                        private String fullName;
                        private String phone;
                    }package com.psychology.dto;

                     import lombok.AllArgsConstructor;
                     import lombok.Data;
                     import lombok.NoArgsConstructor;

                     import java.time.LocalDateTime;

                     public class ChatDTO {

                         @Data
                         public static class SendMessageRequest {
                             private Long receiverId;
                             private String content;
                             private String attachmentUrl;
                         }

                         @Data
                         @AllArgsConstructor
                         @NoArgsConstructor
                         public static class MessageResponse {
                             private Long id;
                             private Long senderId;
                             private String senderName;
                             private String senderRole;
                             private Long receiverId;
                             private String receiverName;
                             private String content;
                             private String attachmentUrl;
                             private boolean read;
                             private LocalDateTime sentAt;
                         }

                         @Data
                         public static class ConversationRequest {
                             private Long otherUserId;
                         }

                         @Data
                         public static class MarkAsReadRequest {
                             private Long messageId;
                         }

                         @Data
                         @AllArgsConstructor
                         @NoArgsConstructor
                         public static class UnreadCountResponse {
                             private Long unreadCount;
                         }

                         @Data
                         @AllArgsConstructor
                         @NoArgsConstructor
                         public static class ChatNotification {
                             private Long messageId;
                             private Long senderId;
                             private String senderName;
                             private String content;
                             private LocalDateTime sentAt;
                         }
                     }package com.psychology.dto;

                      import lombok.Data;

                      import java.time.LocalDateTime;

                      @Data
                      public class ClientDTO {
                          private Long id;
                          private String phone;
                          private String fullName;
                          private Integer age;
                          private String photoUrl;
                          private LocalDateTime linkedAt;
                          private PsychologistInfoDTO psychologist; // Только ID и имя
                      }
package com.psychology.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.Data;

@Data
public class ClientRegisterRequest {
    @NotBlank
    private String phone;

    @NotBlank
    private String otp;

    @NotBlank
    private String fullName;

    @NotNull
    private Integer age;

    private String photoUrl;
}package com.psychology.dto;

 import lombok.Data;

 import java.time.LocalDateTime;
 import java.util.List;

 @Data
 public class DashboardDTO {
     // Общие поля
     private UserType userType;
     private LocalDateTime lastLogin;

     // Для психолога
     private Long totalClients;
     private Long upcomingSessions;
     private Long unreadMessages;
     private Double monthlyRevenue;

     // Для клиента
     private String psychologistName;
     private LocalDateTime nextSession;
     private Long pendingTasks;

     @Data
     public static class QuickStats {
         private String title;
         private Long value;
         private String change; // "+12%"
         private String icon;
     }

     @Data
     public static class ActivityItem {
         private LocalDateTime time;
         private String type; // "session", "message", "journal", "recommendation"
         private String description;
         private String user; // для психолога: имя клиента
         private boolean isNew;
     }

     public enum UserType {
         CLIENT, PSYCHOLOGIST, ADMIN
     }
 }package com.psychology.dto;

  import lombok.Data;
  import java.time.LocalDateTime;

  @Data
  public class InviteDTO {
      private String token;
      private LocalDateTime createdAt;
      private LocalDateTime expiresAt;
      private boolean used;
      private String psychologistName;
  }package com.psychology.dto;

   import jakarta.validation.constraints.NotBlank;
   import jakarta.validation.constraints.Pattern;
   import lombok.Data;

   @Data
   public class PhoneRequest {
       @NotBlank(message = "Phone number is required")
       @Pattern(regexp = "^\\+?[1-9]\\d{1,14}$", message = "Invalid phone number format")
       private String phone;
   }package com.psychology.dto;

    import lombok.Data;

    import java.time.LocalDateTime;

    @Data
    public class PsychologistDTO {
        private Long id;
        private String phone;
        private String fullName;
        private String email;
        private String education;
        private String specialization;
        private String description;
        private String photoUrl;
        private boolean verified;
        private LocalDateTime verifiedAt;
        private LocalDateTime createdAt;
    }package com.psychology.dto;

     import lombok.Data;

     @Data
     public class PsychologistInfoDTO {
         private Long id;
         private String fullName;
         private String specialization;
     }package com.psychology.dto;

      import jakarta.validation.constraints.Email;
      import jakarta.validation.constraints.NotBlank;
      import lombok.Data;

      @Data
      public class PsychologistRegisterRequest {
          @NotBlank
          private String phone;

          @NotBlank
          private String otp;

          @NotBlank
          private String fullName;

          @NotBlank
          @Email
          private String email;

          private String education;
          private String specialization;
          private String description;
          private String photoUrl;
      }package com.psychology.dto;

       import lombok.Data;

       @Data
       public class TypingNotificationDTO {
           private Long senderId;
           private boolean typing;

           public TypingNotificationDTO() {}

           public TypingNotificationDTO(Long senderId, boolean typing) {
               this.senderId = senderId;
               this.typing = typing;
           }
       }package com.psychology.dto;

        import jakarta.validation.constraints.NotBlank;
        import lombok.Data;

        @Data
        public class VerifyOtpRequest {
            @NotBlank
            private String phone;

            @NotBlank
            private String otp;
        }package com.psychology.dto;

         public class Views {
             public static class Public {}
             public static class Internal extends Public {}
             public static class Detailed extends Internal {}
         }
package com.psychology.exception;

import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.context.request.WebRequest;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

@ControllerAdvice
@Slf4j
public class GlobalExceptionHandler {

    @ExceptionHandler(Exception.class)
    public ResponseEntity<Object> handleAllExceptions(Exception ex, WebRequest request) {
        log.error("Unhandled exception: ", ex);

        Map<String, Object> body = new HashMap<>();
        body.put("timestamp", LocalDateTime.now());
        body.put("status", HttpStatus.INTERNAL_SERVER_ERROR.value());
        body.put("error", "Internal Server Error");
        body.put("message", ex.getMessage());
        body.put("path", request.getDescription(false));

        // Для дебага - добавляем stack trace
        if (ex.getStackTrace() != null && ex.getStackTrace().length > 0) {
            StackTraceElement first = ex.getStackTrace()[0];
            body.put("location", first.getClassName() + "." + first.getMethodName() + ":" + first.getLineNumber());
        }

        return new ResponseEntity<>(body, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}package com.psychology.model.entity;

 import com.fasterxml.jackson.annotation.JsonIgnore;
 import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
 import com.fasterxml.jackson.annotation.JsonView;
 import com.psychology.dto.Views;
 import jakarta.persistence.*;
 import lombok.Data;
 import lombok.EqualsAndHashCode;

 import java.time.LocalDateTime;

 @Entity
 @Table(name = "clients")
 @Data
 @EqualsAndHashCode(callSuper = true)
 public class Client extends User {
     @Column(name = "full_name", nullable = false)
     private String fullName;

     private Integer age;

     private String photoUrl;

     @ManyToOne(fetch = FetchType.LAZY)
     @JoinColumn(name = "psychologist_id", nullable = false)
     @JsonView(Views.Internal.class)
     @JsonIgnoreProperties(value = {"psychologist.clients", "psychologist.invites"}, allowSetters = true)
     private Psychologist psychologist;

     @Column(name = "linked_at")
     private LocalDateTime linkedAt;

     @Override
     public String toString() {
         return "Client{" +
                 "id=" + getId() +
                 ", phone='" + getPhone() + '\'' +
                 ", fullName='" + fullName + '\'' +
                 ", age=" + age +
                 '}';
     }
 }package com.psychology.model.entity;

  import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
  import jakarta.persistence.*;
  import lombok.Data;

  import java.time.LocalDateTime;

  @Entity
  @Table(name = "invites")
  @Data
  public class Invite {
      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;

      @Column(unique = true, nullable = false)
      private String token;

      @ManyToOne(fetch = FetchType.LAZY)
      @JoinColumn(name = "psychologist_id", nullable = false)
      @JsonIgnoreProperties({"hibernateLazyInitializer", "handler", "clients", "invites"})
      private Psychologist psychologist;

      @Column(name = "created_at")
      private LocalDateTime createdAt = LocalDateTime.now();

      @Column(name = "expires_at")
      private LocalDateTime expiresAt;

      private boolean used = false;

      @Column(name = "used_at")
      private LocalDateTime usedAt;

      @PrePersist
      protected void setExpiration() {
          expiresAt = createdAt.plusDays(7);
      }

      // Переопределяем toString без LAZY полей
      @Override
      public String toString() {
          return "Invite{" +
                  "id=" + id +
                  ", token='" + token + '\'' +
                  ", psychologistId=" + (psychologist != null ? psychologist.getId() : null) +
                  ", createdAt=" + createdAt +
                  ", expiresAt=" + expiresAt +
                  ", used=" + used +
                  '}';
      }
  }package com.psychology.model.entity;

   import jakarta.persistence.*;
   import lombok.Data;
   import org.hibernate.annotations.CreationTimestamp;
   import org.hibernate.annotations.JdbcTypeCode;
   import org.hibernate.type.SqlTypes;

   import java.time.LocalDateTime;
   import java.util.ArrayList;
   import java.util.List;

   @Entity
   @Table(name = "journal_entries")
   @Data
   public class JournalEntry {
       @Id
       @GeneratedValue(strategy = GenerationType.IDENTITY)
       private Long id;

       @ManyToOne(fetch = FetchType.LAZY)
       @JoinColumn(name = "client_id", nullable = false)
       private Client client;

       @Column(columnDefinition = "TEXT", length = 5000)
       private String content;

       private String mood; // можно сделать enum

       @JdbcTypeCode(SqlTypes.JSON)
       @Column(columnDefinition = "jsonb")
       private List<String> tags = new ArrayList<>();

       @CreationTimestamp
       private LocalDateTime createdAt;

       // Дополнительно: дата обновления
       private LocalDateTime updatedAt;

       @PreUpdate
       protected void onUpdate() {
           updatedAt = LocalDateTime.now();
       }
   }package com.psychology.model.entity;

    import jakarta.persistence.*;
    import lombok.Data;
    import org.hibernate.annotations.CreationTimestamp;

    import java.time.LocalDateTime;

    @Entity
    @Table(name = "messages")
    @Data
    public class Message {
        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        private Long id;

        @ManyToOne(fetch = FetchType.LAZY)
        @JoinColumn(name = "sender_id", nullable = false)
        private User sender;

        @ManyToOne(fetch = FetchType.LAZY)
        @JoinColumn(name = "receiver_id", nullable = false)
        private User receiver;

        @Column(nullable = false, columnDefinition = "TEXT")
        private String content;

        @Column(name = "attachment_url")
        private String attachmentUrl;

        @Column(name = "is_read", nullable = false)
        private boolean read = false;

        @CreationTimestamp
        @Column(name = "sent_at")
        private LocalDateTime sentAt;

        @Override
        public String toString() {
            return "Message{" +
                    "id=" + id +
                    ", senderId=" + (sender != null ? sender.getId() : null) +
                    ", receiverId=" + (receiver != null ? receiver.getId() : null) +
                    ", content='" + (content != null ? content.substring(0, Math.min(content.length(), 50)) : "") + '\'' +
                    ", sentAt=" + sentAt +
                    ", read=" + read +
                    '}';
        }
    }package com.psychology.model.entity;

     public enum Mood {
         VERY_HAPPY("😊", "Very Happy"),
         HAPPY("🙂", "Happy"),
         NEUTRAL("😐", "Neutral"),
         SAD("😔", "Sad"),
         VERY_SAD("😢", "Very Sad"),
         ANGRY("😠", "Angry"),
         ANXIOUS("😰", "Anxious"),
         STRESSED("😫", "Stressed"),
         TIRED("😴", "Tired"),
         EXCITED("🤩", "Excited"),
         PEACEFUL("😌", "Peaceful"),
         CONFUSED("😕", "Confused");

         private final String emoji;
         private final String description;

         Mood(String emoji, String description) {
             this.emoji = emoji;
             this.description = description;
         }

         public String getEmoji() {
             return emoji;
         }

         public String getDescription() {
             return description;
         }

         public static Mood fromString(String mood) {
             for (Mood m : Mood.values()) {
                 if (m.name().equalsIgnoreCase(mood) || m.getDescription().equalsIgnoreCase(mood)) {
                     return m;
                 }
             }
             return null;
         }
     }package com.psychology.model.entity;

      import jakarta.persistence.*;
      import lombok.Data;
      import org.hibernate.annotations.CreationTimestamp;

      import java.time.LocalDateTime;

      @Entity
      @Table(name = "notifications")
      @Data
      public class Notification {
          @Id
          @GeneratedValue(strategy = GenerationType.IDENTITY)
          private Long id;

          @ManyToOne(fetch = FetchType.LAZY)
          @JoinColumn(name = "user_id", nullable = false)
          private User user;

          @Enumerated(EnumType.STRING)
          private NotificationType type;

          private String title;

          @Column(columnDefinition = "TEXT")
          private String message;

          @Column(name = "is_read", nullable = false)
          private boolean read = false;

          @Column(name = "related_entity_id")
          private Long relatedEntityId; // ID связанной сущности (сеанса, сообщения, рекомендации)

          @Column(name = "related_entity_type")
          private String relatedEntityType; // Тип связанной сущности: SESSION, MESSAGE, RECOMMENDATION, etc.

          @CreationTimestamp
          private LocalDateTime createdAt;

          public enum NotificationType {
              // Чат
              NEW_MESSAGE,

              // Сеансы
              SESSION_REMINDER_24H,
              SESSION_REMINDER_1H,
              SESSION_CREATED,
              SESSION_UPDATED,
              SESSION_CANCELLED,
              SESSION_CONFIRMED,

              // Рекомендации
              NEW_RECOMMENDATION,
              RECOMMENDATION_UPDATED,
              RECOMMENDATION_OVERDUE,

              // Дневник
              JOURNAL_REMINDER, // напоминание о заполнении дневника

              // Системные
              SYSTEM_ANNOUNCEMENT,

              // Прочее
              INFO
          }
      }package com.psychology.model.entity;

       import com.fasterxml.jackson.annotation.JsonIgnore;
       import jakarta.persistence.*;
       import lombok.Data;
       import lombok.EqualsAndHashCode;

       import java.time.LocalDateTime;
       import java.util.List;

       @Entity
       @Table(name = "psychologists")
       @Data
       @EqualsAndHashCode(callSuper = true)
       public class Psychologist extends User {
           @Column(name = "full_name", nullable = false)
           private String fullName;

           @Column(nullable = false)
           private String email;

           private String education;

           private String specialization;

           @Column(columnDefinition = "TEXT")
           private String description;

           private String photoUrl;

           private boolean verified = false;

           @Column(name = "verified_at")
           private LocalDateTime verifiedAt;

           @OneToMany(mappedBy = "psychologist", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
           @JsonIgnore
           private List<Client> clients;

           @OneToMany(mappedBy = "psychologist", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
           @JsonIgnore
           private List<Invite> invites;

           // ОСТАВЛЯЕМ: При toString() исключаем ленивые коллекции
           @Override
           public String toString() {
               return "Psychologist{" +
                       "id=" + getId() +
                       ", phone='" + getPhone() + '\'' +
                       ", fullName='" + fullName + '\'' +
                       ", email='" + email + '\'' +
                       ", verified=" + verified +
                       '}';
           }

           @PrePersist
           @PreUpdate
           protected void onUpdate() {
               if (verified && verifiedAt == null) {
                   verifiedAt = LocalDateTime.now();
               }
           }
       }package com.psychology.model.entity;

        import jakarta.persistence.*;
        import lombok.Data;
        import org.hibernate.annotations.CreationTimestamp;
        import org.hibernate.annotations.JdbcTypeCode;
        import org.hibernate.type.SqlTypes;

        import java.time.LocalDateTime;
        import java.util.ArrayList;
        import java.util.List;

        @Entity
        @Table(name = "recommendations")
        @Data
        public class Recommendation {
            @Id
            @GeneratedValue(strategy = GenerationType.IDENTITY)
            private Long id;

            @ManyToOne(fetch = FetchType.LAZY)
            @JoinColumn(name = "psychologist_id", nullable = false)
            private Psychologist psychologist;

            @ManyToOne(fetch = FetchType.LAZY)
            @JoinColumn(name = "client_id", nullable = false)
            private Client client;

            @Column(nullable = false)
            private String title;

            @Column(columnDefinition = "TEXT", nullable = false)
            private String content;

            private LocalDateTime deadline;

            @Column(nullable = false)
            private Integer priority = 3; // 1-5, где 5 - наивысший

            @JdbcTypeCode(SqlTypes.JSON)
            @Column(columnDefinition = "jsonb")
            private List<String> categories = new ArrayList<>();

            @Column(nullable = false)
            private boolean completed = false;

            @Column(name = "completed_by_client", nullable = false)
            private boolean completedByClient = false;

            @Column(name = "completed_at")
            private LocalDateTime completedAt;

            @CreationTimestamp
            private LocalDateTime createdAt;

            private LocalDateTime updatedAt;

            @PreUpdate
            protected void onUpdate() {
                updatedAt = LocalDateTime.now();
            }
        }package com.psychology.model.entity;

         import jakarta.persistence.*;
         import lombok.Data;

         import java.time.LocalDateTime;

         @Entity
         @Table(name = "sessions")
         @Data
         public class Session {
             @Id
             @GeneratedValue(strategy = GenerationType.IDENTITY)
             private Long id;

             @ManyToOne(fetch = FetchType.LAZY)
             @JoinColumn(name = "psychologist_id", nullable = false)
             private Psychologist psychologist;

             @ManyToOne(fetch = FetchType.LAZY)
             @JoinColumn(name = "client_id", nullable = false)
             private Client client;

             @Column(name = "scheduled_at", nullable = false)
             private LocalDateTime scheduledAt;

             @Column(name = "duration_minutes")
             private Integer durationMinutes = 50;

             private String description;

             @Enumerated(EnumType.STRING)
             private SessionStatus status = SessionStatus.SCHEDULED;

             @Column(name = "created_at")
             private LocalDateTime createdAt = LocalDateTime.now();

             @Column(name = "updated_at")
             private LocalDateTime updatedAt = LocalDateTime.now();

             @PreUpdate
             protected void onUpdate() {
                 updatedAt = LocalDateTime.now();
             }

             public enum SessionStatus {
                 SCHEDULED,      // Запланирован
                 CONFIRMED,      // Подтвержден клиентом
                 IN_PROGRESS,    // В процессе (для будущего)
                 COMPLETED,      // Завершен
                 CANCELLED,      // Отменен
                 RESCHEDULED     // Перенесен
             }
         }package com.psychology.model.entity;

          import jakarta.persistence.*;
          import lombok.Data;
          import org.hibernate.annotations.CreationTimestamp;
          import org.hibernate.annotations.UpdateTimestamp;
          import org.springframework.security.core.GrantedAuthority;
          import org.springframework.security.core.authority.SimpleGrantedAuthority;

          import java.time.LocalDateTime;
          import java.util.Collection;
          import java.util.Collections;

          @Entity
          @Table(name = "users")
          @Inheritance(strategy = InheritanceType.JOINED)
          @Data
          public abstract class User {
              @Id
              @GeneratedValue(strategy = GenerationType.IDENTITY)
              private Long id;

              @Column(unique = true, nullable = false)
              private String phone;

              @Enumerated(EnumType.STRING)
              private UserRole role;

              @CreationTimestamp
              @Column(name = "created_at", updatable = false)
              private LocalDateTime createdAt;

              @UpdateTimestamp
              @Column(name = "updated_at")
              private LocalDateTime updatedAt;

              public Collection<? extends GrantedAuthority> getAuthorities() {
                  return Collections.singletonList(new SimpleGrantedAuthority(role.name()));
              }

              @Override
              public String toString() {
                  return "User{" +
                          "id=" + id +
                          ", phone='" + phone + '\'' +
                          ", role=" + role +
                          '}';
              }
          }package com.psychology.model.entity;

           public enum UserRole {
               ROLE_CLIENT,
               ROLE_PSYCHOLOGIST,
               ROLE_ADMIN
           }package com.psychology.ratelimiting;

            import jakarta.servlet.http.HttpServletRequest;
            import jakarta.servlet.http.HttpServletResponse;
            import lombok.RequiredArgsConstructor;
            import lombok.extern.slf4j.Slf4j;
            import org.springframework.data.redis.core.StringRedisTemplate;
            import org.springframework.stereotype.Component;
            import org.springframework.web.servlet.HandlerInterceptor;

            import java.time.Duration;
            import java.util.concurrent.TimeUnit;

            @Component
            @RequiredArgsConstructor
            @Slf4j
            public class RateLimitInterceptor implements HandlerInterceptor {

                private final StringRedisTemplate redisTemplate;

                // Лимиты запросов
                private static final int AUTH_LIMIT = 10; // 10 запросов в минуту на авторизацию
                private static final int OTP_LIMIT = 3; // 3 запроса OTP в минуту
                private static final Duration WINDOW = Duration.ofMinutes(1);

                @Override
                public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
                    String ip = getClientIp(request);
                    String path = request.getRequestURI();
                    String key;
                    int limit;

                    // Определяем лимит в зависимости от пути
                    if (path.contains("/auth/send-otp")) {
                        key = "rate_limit:otp:" + ip;
                        limit = OTP_LIMIT;
                    } else if (path.contains("/auth/")) {
                        key = "rate_limit:auth:" + ip;
                        limit = AUTH_LIMIT;
                    } else {
                        return true; // Для других путей не применяем rate limiting
                    }

                    // Проверяем количество запросов
                    Long current = redisTemplate.opsForValue().increment(key);
                    if (current == null) {
                        // Ошибка Redis, пропускаем
                        return true;
                    }

                    if (current == 1) {
                        // Первый запрос, устанавливаем TTL
                        redisTemplate.expire(key, WINDOW.getSeconds(), TimeUnit.SECONDS);
                    }

                    if (current > limit) {
                        log.warn("Rate limit exceeded for IP: {}, path: {}", ip, path);
                        response.setStatus(429); // Too Many Requests
                        response.getWriter().write("Rate limit exceeded. Please try again later.");
                        return false;
                    }

                    return true;
                }

                private String getClientIp(HttpServletRequest request) {
                    String xForwardedFor = request.getHeader("X-Forwarded-For");
                    if (xForwardedFor != null && !xForwardedFor.isEmpty()) {
                        return xForwardedFor.split(",")[0].trim();
                    }
                    return request.getRemoteAddr();
                }
            }package com.psychology.repository;

             import com.psychology.model.entity.Client;
             import com.psychology.model.entity.Psychologist;
             import org.springframework.data.jpa.repository.JpaRepository;
             import org.springframework.stereotype.Repository;

             import java.util.List;

             @Repository
             public interface ClientRepository extends JpaRepository<Client, Long> {
                 List<Client> findByPsychologist(Psychologist psychologist);
                 List<Client> findByPsychologistId(Long psychologistId);
             }package com.psychology.repository;

              import com.psychology.model.entity.Invite;
              import org.springframework.data.jpa.repository.JpaRepository;
              import org.springframework.data.jpa.repository.Query;
              import org.springframework.data.repository.query.Param;
              import org.springframework.stereotype.Repository;

              import java.util.List;
              import java.util.Optional;

              @Repository
              public interface InviteRepository extends JpaRepository<Invite, Long> {
                  Optional<Invite> findByToken(String token);

                  // Кастомный запрос с JOIN FETCH для загрузки psychologist
                  @Query("SELECT i FROM Invite i JOIN FETCH i.psychologist WHERE i.token = :token")
                  Optional<Invite> findByTokenWithPsychologist(@Param("token") String token);

                  boolean existsByToken(String token);
                  List<Invite> findByPsychologistIdAndUsedFalse(Long psychologistId);
              }package com.psychology.repository;

               import com.psychology.model.entity.JournalEntry;
               import org.springframework.data.domain.Pageable;
               import org.springframework.data.jpa.repository.JpaRepository;
               import org.springframework.data.jpa.repository.Query;
               import org.springframework.data.repository.query.Param;
               import org.springframework.stereotype.Repository;

               import java.time.LocalDateTime;
               import java.util.List;

               @Repository
               public interface JournalEntryRepository extends JpaRepository<JournalEntry, Long> {

                   List<JournalEntry> findByClientIdOrderByCreatedAtDesc(Long clientId);

                   @Query("SELECT je FROM JournalEntry je WHERE je.client.id = :clientId ORDER BY je.createdAt DESC")
                   List<JournalEntry> findByClientId(@Param("clientId") Long clientId, Pageable pageable);

                   List<JournalEntry> findByClientId(@Param("clientId") Long clientId);


                   long countByClientIdAndCreatedAtBetween(Long clientId, LocalDateTime start, LocalDateTime end);

                   List<JournalEntry> findByCreatedAtBefore(LocalDateTime date);

                   @Query("SELECT DISTINCT je FROM JournalEntry je JOIN je.tags tag WHERE je.client.id = :clientId AND tag = :tag")
                   List<JournalEntry> findByClientIdAndTag(@Param("clientId") Long clientId, @Param("tag") String tag);
               }package com.psychology.repository;

                import com.psychology.model.entity.Message;
                import com.psychology.model.entity.User;
                import org.springframework.data.jpa.repository.JpaRepository;
                import org.springframework.data.jpa.repository.Query;
                import org.springframework.data.repository.query.Param;
                import org.springframework.stereotype.Repository;

                import java.time.LocalDateTime;
                import java.util.List;

                @Repository
                public interface MessageRepository extends JpaRepository<Message, Long> {

                    @Query("SELECT m FROM Message m WHERE " +
                            "(m.sender.id = :user1Id AND m.receiver.id = :user2Id) OR " +
                            "(m.sender.id = :user2Id AND m.receiver.id = :user1Id) " +
                            "ORDER BY m.sentAt ASC")
                    List<Message> findConversation(@Param("user1Id") Long user1Id,
                                                   @Param("user2Id") Long user2Id);

                    @Query("SELECT m FROM Message m WHERE " +
                            "(m.sender.id = :userId OR m.receiver.id = :userId) AND " +
                            "m.sentAt > :since " +
                            "ORDER BY m.sentAt DESC")
                    List<Message> findRecentMessages(@Param("userId") Long userId,
                                                     @Param("since") LocalDateTime since);

                    @Query("SELECT m FROM Message m WHERE " +
                            "m.receiver.id = :userId AND m.read = false")
                    List<Message> findUnreadMessages(@Param("userId") Long userId);

                    @Query("SELECT m FROM Message m WHERE " +
                            "(m.sender.id = :userId OR m.receiver.id = :userId) " +
                            "ORDER BY m.sentAt DESC")
                    List<Message> findAllUserMessages(@Param("userId") Long userId);

                    long countByReceiverIdAndReadFalse(Long receiverId);
                }package com.psychology.repository;

                 import com.psychology.model.entity.Notification;
                 import com.psychology.model.entity.User;
                 import org.springframework.data.domain.Pageable;
                 import org.springframework.data.jpa.repository.JpaRepository;
                 import org.springframework.data.jpa.repository.Modifying;
                 import org.springframework.data.jpa.repository.Query;
                 import org.springframework.data.repository.query.Param;
                 import org.springframework.stereotype.Repository;

                 import java.time.LocalDateTime;
                 import java.util.List;

                 @Repository
                 public interface NotificationRepository extends JpaRepository<Notification, Long> {

                     List<Notification> findByUserOrderByCreatedAtDesc(User user);

                     List<Notification> findByUserAndReadOrderByCreatedAtDesc(User user, boolean read);

                     List<Notification> findByUser(User user, Pageable pageable);

                     long countByUserAndRead(User user, boolean read);

                     @Query("SELECT n FROM Notification n WHERE n.user = :user AND n.createdAt >= :since ORDER BY n.createdAt DESC")
                     List<Notification> findByUserSince(@Param("user") User user, @Param("since") LocalDateTime since);

                     @Modifying
                     @Query("UPDATE Notification n SET n.read = true WHERE n.user = :user AND n.read = false")
                     void markAllAsReadByUser(@Param("user") User user);

                     @Modifying
                     @Query("DELETE FROM Notification n WHERE n.user = :user AND n.createdAt < :expirationDate")
                     void deleteOldNotifications(@Param("user") User user, @Param("expirationDate") LocalDateTime expirationDate);

                     @Query("SELECT n FROM Notification n WHERE n.user = :user AND n.type = :type AND n.relatedEntityId = :relatedEntityId")
                     List<Notification> findByUserAndTypeAndRelatedEntityId(@Param("user") User user,
                                                                            @Param("type") Notification.NotificationType type,
                                                                            @Param("relatedEntityId") Long relatedEntityId);
                 }package com.psychology.repository;

                  import com.psychology.model.entity.Psychologist;
                  import org.springframework.data.jpa.repository.JpaRepository;
                  import org.springframework.data.jpa.repository.Query;
                  import org.springframework.stereotype.Repository;

                  import java.util.List;
                  import java.util.Optional;

                  @Repository
                  public interface PsychologistRepository extends JpaRepository<Psychologist, Long> {
                      List<Psychologist> findByVerified(boolean verified);

                      Optional<Psychologist> findByPhone(String phone);

                      default List<Psychologist> findByVerifiedFalse() {
                          return findByVerified(false);
                      }

                      default List<Psychologist> findByVerifiedTrue() {
                          return findByVerified(true);
                      }

                      @Query("SELECT COUNT(p) FROM Psychologist p WHERE p.verified = true")
                      long countByVerifiedTrue();

                      @Query("SELECT COUNT(p) FROM Psychologist p WHERE p.verified = false")
                      long countByVerifiedFalse();
                  }package com.psychology.repository;

                   import com.psychology.model.entity.Recommendation;
                   import org.springframework.data.jpa.repository.JpaRepository;
                   import org.springframework.data.jpa.repository.Query;
                   import org.springframework.data.repository.query.Param;
                   import org.springframework.stereotype.Repository;

                   import java.time.LocalDateTime;
                   import java.util.List;

                   @Repository
                   public interface RecommendationRepository extends JpaRepository<Recommendation, Long> {

                       List<Recommendation> findByClientId(Long clientId);

                       List<Recommendation> findByPsychologistId(Long psychologistId);

                       List<Recommendation> findByClientIdAndCompleted(Long clientId, boolean completed);

                       @Query("SELECT r FROM Recommendation r WHERE r.client.psychologist.id = :psychologistId AND r.completed = false AND r.deadline < :now")
                       List<Recommendation> findOverdueByPsychologistId(@Param("psychologistId") Long psychologistId, @Param("now") LocalDateTime now);

                       @Query("SELECT r FROM Recommendation r WHERE r.completed = false AND r.deadline < :deadline")
                       List<Recommendation> findOverdueRecommendations(@Param("deadline") LocalDateTime deadline);

                       @Query("SELECT r FROM Recommendation r WHERE r.client.id = :clientId AND r.completed = false ORDER BY r.priority DESC, r.deadline ASC")
                       List<Recommendation> findActiveByClientId(@Param("clientId") Long clientId);

                       long countByClientIdAndCompleted(Long clientId, boolean completed);
                   }package com.psychology.repository;

                    import com.psychology.model.entity.Session;
                    import com.psychology.model.entity.Psychologist;
                    import com.psychology.model.entity.Client;
                    import org.springframework.data.jpa.repository.JpaRepository;
                    import org.springframework.data.jpa.repository.Query;
                    import org.springframework.data.repository.query.Param;
                    import org.springframework.stereotype.Repository;

                    import java.time.LocalDateTime;
                    import java.util.List;

                    @Repository
                    public interface SessionRepository extends JpaRepository<Session, Long> {

                        List<Session> findByPsychologistIdOrderByScheduledAtDesc(Long psychologistId);

                        List<Session> findByClientIdOrderByScheduledAtDesc(Long clientId);

                        List<Session> findByPsychologistIdAndScheduledAtBetween(
                                Long psychologistId, LocalDateTime start, LocalDateTime end);

                        List<Session> findByClientIdAndScheduledAtBetween(
                                Long clientId, LocalDateTime start, LocalDateTime end);

                        List<Session> findByPsychologistIdAndStatus(Long psychologistId, Session.SessionStatus status);

                        List<Session> findByClientIdAndStatus(Long clientId, Session.SessionStatus status);

                        @Query("SELECT COUNT(s) FROM Session s WHERE s.status = :status AND s.scheduledAt BETWEEN :start AND :end")
                        long countByStatusAndDateTimeBetween(
                                @Param("status") String status,
                                @Param("start") LocalDateTime start,
                                @Param("end") LocalDateTime end);

                        List<Session> findByScheduledAtBetween(LocalDateTime start, LocalDateTime end);
                    }package com.psychology.repository;

                     import com.psychology.model.entity.User;
                     import org.springframework.data.jpa.repository.JpaRepository;
                     import org.springframework.data.jpa.repository.Query;
                     import org.springframework.data.repository.query.Param;
                     import org.springframework.stereotype.Repository;

                     import java.util.Optional;

                     @Repository
                     public interface UserRepository extends JpaRepository<User, Long> {

                         @Query("SELECT u FROM User u WHERE u.phone = :phone")
                         Optional<User> findByPhone(@Param("phone") String phone);

                         boolean existsByPhone(String phone);
                     }package com.psychology.scheduler;

                      import com.psychology.model.entity.Session;
                      import com.psychology.repository.SessionRepository;
                      import com.psychology.service.JournalService;
                      import com.psychology.service.NotificationService;
                      import com.psychology.service.RecommendationService;
                      import lombok.RequiredArgsConstructor;
                      import lombok.extern.slf4j.Slf4j;
                      import org.springframework.scheduling.annotation.EnableScheduling;
                      import org.springframework.scheduling.annotation.Scheduled;
                      import org.springframework.stereotype.Component;

                      import java.time.LocalDateTime;
                      import java.util.List;

                      @Component
                      @EnableScheduling
                      @RequiredArgsConstructor
                      @Slf4j
                      public class ScheduledTasks {

                          private final SessionRepository sessionRepository;
                          private final NotificationService notificationService;
                          private final JournalService journalService;
                          private final RecommendationService recommendationService;

                          // Проверка сеансов для напоминаний (каждые 30 минут)
                          @Scheduled(fixedRate = 30 * 60 * 1000) // 30 минут
                          public void checkSessionReminders() {
                              LocalDateTime now = LocalDateTime.now();

                              // Напоминания за 24 часа
                              LocalDateTime in24Hours = now.plusHours(24);
                              List<Session> sessions24h = sessionRepository.findByScheduledAtBetween(
                                      in24Hours.minusMinutes(30), in24Hours.plusMinutes(30));

                              sessions24h.forEach(session -> {
                                  // Создаем уведомление для клиента
                                  notificationService.createNotification(
                                          session.getClient(),
                                          com.psychology.model.entity.Notification.NotificationType.SESSION_REMINDER_24H,
                                          "Напоминание о сеансе",
                                          String.format("У вас запланирован сеанс через 24 часа: %s",
                                                  session.getScheduledAt().toLocalDate()),
                                          session.getId(),
                                          "SESSION"
                                  );

                                  // Создаем уведомление для психолога
                                  notificationService.createNotification(
                                          session.getPsychologist(),
                                          com.psychology.model.entity.Notification.NotificationType.SESSION_REMINDER_24H,
                                          "Напоминание о сеансе",
                                          String.format("У вас запланирован сеанс с %s через 24 часа",
                                                  session.getClient().getFullName()),
                                          session.getId(),
                                          "SESSION"
                                  );
                              });

                              // Напоминания за 1 час
                              LocalDateTime in1Hour = now.plusHours(1);
                              List<Session> sessions1h = sessionRepository.findByScheduledAtBetween(
                                      in1Hour.minusMinutes(15), in1Hour.plusMinutes(15));

                              sessions1h.forEach(session -> {
                                  notificationService.createNotification(
                                          session.getClient(),
                                          com.psychology.model.entity.Notification.NotificationType.SESSION_REMINDER_1H,
                                          "Скоро начнется сеанс",
                                          "До начала сеанса остался 1 час",
                                          session.getId(),
                                          "SESSION"
                                  );

                                  notificationService.createNotification(
                                          session.getPsychologist(),
                                          com.psychology.model.entity.Notification.NotificationType.SESSION_REMINDER_1H,
                                          "Скоро начнется сеанс",
                                          String.format("До начала сеанса с %s остался 1 час",
                                                  session.getClient().getFullName()),
                                          session.getId(),
                                          "SESSION"
                                  );
                              });
                          }

                          // Очистка старых записей дневника (раз в день)
                          @Scheduled(cron = "0 0 2 * * ?") // В 2:00 ночи каждый день
                          public void cleanupOldData() {
                              log.info("Starting scheduled cleanup of old data");

                              // Очистка записей дневника старше 3 лет
                              journalService.cleanupOldEntries();

                              // Очистка старых уведомлений
                              notificationService.cleanupOldNotifications();

                              log.info("Scheduled cleanup completed");
                          }

                          // Проверка просроченных рекомендаций (раз в день)
                          @Scheduled(cron = "0 0 8 * * ?") // В 8:00 утра каждый день
                          public void checkOverdueRecommendations() {
                              log.info("Checking for overdue recommendations");
                              recommendationService.checkAndNotifyOverdue();
                          }
                      }package com.psychology.security;

                       import com.psychology.model.entity.User;
                       import com.psychology.repository.UserRepository;
                       import lombok.RequiredArgsConstructor;
                       import org.springframework.security.core.authority.SimpleGrantedAuthority;
                       import org.springframework.security.core.userdetails.UserDetails;
                       import org.springframework.security.core.userdetails.UserDetailsService;
                       import org.springframework.security.core.userdetails.UsernameNotFoundException;
                       import org.springframework.stereotype.Service;

                       import java.util.Collections;

                       @Service
                       @RequiredArgsConstructor
                       public class CustomUserDetailsService implements UserDetailsService {

                           private final UserRepository userRepository;

                           @Override
                           public UserDetails loadUserByUsername(String phone) throws UsernameNotFoundException {
                               User user = userRepository.findByPhone(phone)
                                       .orElseThrow(() -> new UsernameNotFoundException("User not found with phone: " + phone));

                               return new org.springframework.security.core.userdetails.User(
                                       user.getPhone(),
                                       "", // Пароль не используется в OTP системе
                                       Collections.singletonList(new SimpleGrantedAuthority(user.getRole().name()))
                               );
                           }
                       }package com.psychology.security;

                        import com.psychology.model.entity.User;
                        import com.psychology.repository.UserRepository;
                        import jakarta.servlet.FilterChain;
                        import jakarta.servlet.ServletException;
                        import jakarta.servlet.http.HttpServletRequest;
                        import jakarta.servlet.http.HttpServletResponse;
                        import lombok.RequiredArgsConstructor;
                        import lombok.extern.slf4j.Slf4j;
                        import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
                        import org.springframework.security.core.authority.SimpleGrantedAuthority;
                        import org.springframework.security.core.context.SecurityContextHolder;
                        import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
                        import org.springframework.stereotype.Component;
                        import org.springframework.web.filter.OncePerRequestFilter;

                        import java.io.IOException;
                        import java.util.Collections;
                        @Component
                        @RequiredArgsConstructor
                        @Slf4j
                        public class JwtAuthenticationFilter extends OncePerRequestFilter {
                            private final JwtTokenProvider jwtTokenProvider;
                            private final UserRepository userRepository;

                            @Override
                            protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
                                    throws ServletException, IOException {
                                try {
                                    final String authHeader = request.getHeader("Authorization");
                                    final String requestUri = request.getRequestURI();

                                    log.debug("Processing request: {} {}", request.getMethod(), requestUri);

                                    // Пропускаем публичные эндпоинты
                                    if (requestUri.startsWith("/api/v1/auth/") ||
                                            requestUri.startsWith("/api/v1/invites/validate/") ||
                                            requestUri.startsWith("/api/v1/test/") ||
                                            requestUri.startsWith("/api/v1/debug/") ||
                                            requestUri.equals("/error")) {
                                        filterChain.doFilter(request, response);
                                        return;
                                    }

                                    if (authHeader == null || !authHeader.startsWith("Bearer ")) {
                                        log.warn("No Bearer token found for protected endpoint: {}", requestUri);
                                        filterChain.doFilter(request, response);
                                        return;
                                    }

                                    final String jwt = authHeader.substring(7);

                                    if (!jwtTokenProvider.validateToken(jwt)) {
                                        log.warn("Invalid or expired token");
                                        filterChain.doFilter(request, response);
                                        return;
                                    }

                                    final String phone = jwtTokenProvider.extractUsername(jwt);
                                    log.debug("Extracted phone from token: {}", phone);

                                    if (phone != null && SecurityContextHolder.getContext().getAuthentication() == null) {
                                        // Загружаем пользователя из базы
                                        User user = userRepository.findByPhone(phone)
                                                .orElse(null);

                                        if (user != null) {
                                            log.debug("Loaded user: ID={}, Role={}", user.getId(), user.getRole());

                                            UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken(
                                                    user,
                                                    null,
                                                    Collections.singletonList(new SimpleGrantedAuthority(user.getRole().name()))
                                            );
                                            authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                                            SecurityContextHolder.getContext().setAuthentication(authToken);
                                            log.debug("Authentication set successfully for user: {}", phone);
                                        }
                                    }
                                } catch (Exception e) {
                                    log.error("Error in JWT filter: ", e);
                                }

                                filterChain.doFilter(request, response);
                            }
                        }package com.psychology.security;

                         import io.jsonwebtoken.Claims;
                         import io.jsonwebtoken.Jwts;
                         import io.jsonwebtoken.SignatureAlgorithm;
                         import io.jsonwebtoken.security.Keys;
                         import org.springframework.beans.factory.annotation.Value;
                         import org.springframework.security.core.userdetails.UserDetails;
                         import org.springframework.stereotype.Component;

                         import javax.crypto.SecretKey;
                         import java.util.Date;
                         import java.util.HashMap;
                         import java.util.Map;
                         import java.util.function.Function;

                         @Component
                         public class JwtTokenProvider {
                             @Value("${jwt.secret}")
                             private String jwtSecret;

                             @Value("${jwt.access-expiration}")
                             private long accessExpiration;

                             @Value("${jwt.refresh-expiration}")
                             private long refreshExpiration;

                             public long getAccessTokenExpirationMs() {
                                 return accessExpiration;
                             }

                             public long getRefreshTokenExpirationMs() {
                                 return refreshExpiration;
                             }

                             private SecretKey getSigningKey() {
                                 return Keys.hmacShaKeyFor(jwtSecret.getBytes());
                             }

                             public String generateAccessToken(UserDetails userDetails) {
                                 Map<String, Object> claims = new HashMap<>();
                                 return buildToken(claims, userDetails.getUsername(), accessExpiration);
                             }

                             public String generateRefreshToken(UserDetails userDetails) {
                                 Map<String, Object> claims = new HashMap<>();
                                 return buildToken(claims, userDetails.getUsername(), refreshExpiration);
                             }

                             private String buildToken(Map<String, Object> claims, String subject, long expiration) {
                                 return Jwts.builder()
                                         .setClaims(claims)
                                         .setSubject(subject)
                                         .setIssuedAt(new Date(System.currentTimeMillis()))
                                         .setExpiration(new Date(System.currentTimeMillis() + expiration))
                                         .signWith(getSigningKey(), SignatureAlgorithm.HS256)
                                         .compact();
                             }

                             public String extractUsername(String token) {
                                 return extractClaim(token, Claims::getSubject);
                             }

                             public Date extractExpiration(String token) {
                                 return extractClaim(token, Claims::getExpiration);
                             }

                             public <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
                                 final Claims claims = extractAllClaims(token);
                                 return claimsResolver.apply(claims);
                             }

                             private Claims extractAllClaims(String token) {
                                 return Jwts.parserBuilder()
                                         .setSigningKey(getSigningKey())
                                         .build()
                                         .parseClaimsJws(token)
                                         .getBody();
                             }

                             public Boolean validateToken(String token) {
                                 try {
                                     Jwts.parserBuilder()
                                             .setSigningKey(getSigningKey())
                                             .build()
                                             .parseClaimsJws(token);
                                     return true;
                                 } catch (Exception e) {
                                     return false;
                                 }
                             }

                             public Boolean validateToken(String token, UserDetails userDetails) {
                                 final String username = extractUsername(token);
                                 return (username.equals(userDetails.getUsername()) && !isTokenExpired(token));
                             }

                             private Boolean isTokenExpired(String token) {
                                 return extractExpiration(token).before(new Date());
                             }
                         }package com.psychology.service;

                          import com.psychology.controller.AdminController;
                          import com.psychology.model.entity.Psychologist;
                          import com.psychology.repository.PsychologistRepository;
                          import com.psychology.repository.ClientRepository;
                          import com.psychology.repository.SessionRepository;
                          import lombok.RequiredArgsConstructor;
                          import org.springframework.stereotype.Service;
                          import org.springframework.transaction.annotation.Transactional;

                          import java.time.LocalDateTime;
                          import java.util.List;

                          @Service
                          @RequiredArgsConstructor
                          public class AdminService {

                              private final PsychologistRepository psychologistRepository;
                              private final ClientRepository clientRepository;
                              private final SessionRepository sessionRepository;

                              public List<Psychologist> getPendingPsychologists() {
                                  return psychologistRepository.findByVerifiedFalse();
                              }

                              public List<Psychologist> getAllPsychologists() {
                                  return psychologistRepository.findAll();
                              }

                              @Transactional
                              public Psychologist verifyPsychologist(Long psychologistId) {
                                  Psychologist psychologist = psychologistRepository.findById(psychologistId)
                                          .orElseThrow(() -> new RuntimeException("Psychologist not found"));

                                  if (psychologist.isVerified()) {
                                      throw new RuntimeException("Psychologist is already verified");
                                  }

                                  psychologist.setVerified(true);
                                  psychologist.setVerifiedAt(LocalDateTime.now());

                                  return psychologistRepository.save(psychologist);
                              }

                              @Transactional
                              public void rejectPsychologist(Long psychologistId, String reason) {
                                  Psychologist psychologist = psychologistRepository.findById(psychologistId)
                                          .orElseThrow(() -> new RuntimeException("Psychologist not found"));

                                  if (psychologist.isVerified()) {
                                      throw new RuntimeException("Cannot reject already verified psychologist");
                                  }

                                  // Здесь можно добавить логику отправки email с причиной отказа
                                  // или сохранить причину в базе данных

                                  psychologistRepository.delete(psychologist);
                              }

                              public AdminController.AdminStats getAdminStats() {
                                  AdminController.AdminStats stats = new AdminController.AdminStats();

                                  stats.setTotalPsychologists(psychologistRepository.count());
                                  stats.setPendingPsychologists(psychologistRepository.countByVerifiedFalse());
                                  stats.setVerifiedPsychologists(psychologistRepository.countByVerifiedTrue());
                                  stats.setTotalClients(clientRepository.count());

                                  // Пример: активные сессии сегодня
                                  LocalDateTime startOfDay = LocalDateTime.now().withHour(0).withMinute(0).withSecond(0);
                                  LocalDateTime endOfDay = LocalDateTime.now().withHour(23).withMinute(59).withSecond(59);
                                  stats.setActiveSessionsToday(sessionRepository.countByStatusAndDateTimeBetween(
                                          "SCHEDULED", startOfDay, endOfDay));

                                  return stats;
                              }
                          }package com.psychology.service;

                           import com.psychology.dto.AuthDTO.*;
                           import com.psychology.model.entity.Client;
                           import com.psychology.model.entity.Invite;
                           import com.psychology.model.entity.Psychologist;
                           import com.psychology.model.entity.UserRole;
                           import com.psychology.repository.ClientRepository;
                           import com.psychology.repository.InviteRepository;
                           import com.psychology.repository.PsychologistRepository;
                           import com.psychology.repository.UserRepository;
                           import com.psychology.security.JwtTokenProvider;
                           import lombok.RequiredArgsConstructor;
                           import lombok.extern.slf4j.Slf4j;
                           import org.springframework.data.redis.core.StringRedisTemplate;
                           import org.springframework.security.core.userdetails.UserDetails;
                           import org.springframework.security.crypto.password.PasswordEncoder;
                           import org.springframework.stereotype.Service;

                           import java.time.LocalDateTime;
                           import java.util.UUID;
                           import java.util.concurrent.TimeUnit;

                           @Service
                           @Slf4j
                           @RequiredArgsConstructor
                           public class AuthService {
                               private final UserRepository userRepository;
                               private final PsychologistRepository psychologistRepository;
                               private final ClientRepository clientRepository;
                               private final InviteRepository inviteRepository;
                               private final OTPService otpService;
                               private final JwtTokenProvider jwtTokenProvider;
                               private final PasswordEncoder passwordEncoder;
                               private final StringRedisTemplate stringRedisTemplate;

                               private static final String BLACKLIST_PREFIX = "blacklist:";
                               private static final String REFRESH_PREFIX = "refresh:";

                               public AuthResponse verifyOTPAndAuthenticate(VerifyOtpRequest request) {
                                   // Проверяем OTP
                                   if (!otpService.verifyOTP(request.getPhone(), request.getOtp())) {
                                       throw new RuntimeException("Invalid OTP");
                                   }

                                   // Ищем пользователя
                                   var user = userRepository.findByPhone(request.getPhone())
                                           .orElseThrow(() -> new RuntimeException("User not found"));

                                   // ВАЖНО: Проверяем верификацию для психологов
                           //        if (user instanceof Psychologist psychologist && !psychologist.isVerified()) {
                           //            throw new RuntimeException("Psychologist account is pending verification by administrator");
                           //        }

                                   log.info("User authenticated: {} with role {}", user.getPhone(), user.getRole());

                                   // Генерируем токены
                                   return generateAuthResponse(user);
                               }

                               public AuthResponse refreshToken(String refreshToken) {
                                   // Проверяем, не в черном списке ли токен
                                   if (Boolean.TRUE.equals(stringRedisTemplate.hasKey(BLACKLIST_PREFIX + refreshToken))) {
                                       throw new RuntimeException("Token is blacklisted");
                                   }

                                   // Валидируем refresh token
                                   if (!jwtTokenProvider.validateToken(refreshToken)) {
                                       throw new RuntimeException("Invalid refresh token");
                                   }

                                   String phone = jwtTokenProvider.extractUsername(refreshToken);
                                   var user = userRepository.findByPhone(phone)
                                           .orElseThrow(() -> new RuntimeException("User not found"));

                                   // Проверяем, что этот refresh token еще валиден
                                   String storedRefreshToken = stringRedisTemplate.opsForValue().get(REFRESH_PREFIX + phone);
                                   if (!refreshToken.equals(storedRefreshToken)) {
                                       throw new RuntimeException("Refresh token mismatch");
                                   }

                                   // Добавляем старый refresh token в blacklist
                                   stringRedisTemplate.opsForValue().set(
                                           BLACKLIST_PREFIX + refreshToken,
                                           "blacklisted",
                                           jwtTokenProvider.getRefreshTokenExpirationMs(), // Время жизни refresh token
                                           TimeUnit.MILLISECONDS
                                   );

                                   // Генерируем новую пару токенов
                                   return generateAuthResponse(user);
                               }

                               public AuthResponse registerPsychologist(PsychologistRegisterRequest request) {
                                   // Проверяем, не занят ли телефон
                                   if (userRepository.existsByPhone(request.getPhone())) {
                                       throw new RuntimeException("Phone already registered");
                                   }

                                   // Создаем психолога
                                   Psychologist psychologist = new Psychologist();
                                   psychologist.setPhone(request.getPhone());
                                   psychologist.setFullName(request.getFullName());
                                   psychologist.setEmail(request.getEmail());
                                   psychologist.setEducation(request.getEducation());
                                   psychologist.setSpecialization(request.getSpecialization());
                                   psychologist.setDescription(request.getDescription());
                                   psychologist.setPhotoUrl(request.getPhotoUrl());
                                   psychologist.setRole(UserRole.ROLE_PSYCHOLOGIST);
                                   psychologist.setVerified(false); // Требуется верификация админом

                                   psychologistRepository.save(psychologist);

                                   return generateAuthResponse(psychologist);
                               }

                               public AuthResponse registerClient(ClientRegisterRequest request, String inviteToken) {
                                   // Проверяем инвайт
                                   Invite invite = inviteRepository.findByToken(inviteToken)
                                           .orElseThrow(() -> new RuntimeException("Invalid invite token"));

                                   if (invite.isUsed()) {
                                       throw new RuntimeException("Invite already used");
                                   }

                                   if (invite.getExpiresAt().isBefore(LocalDateTime.now())) {
                                       throw new RuntimeException("Invite expired");
                                   }

                                   // Проверяем, не занят ли телефон
                                   if (userRepository.existsByPhone(request.getPhone())) {
                                       throw new RuntimeException("Phone already registered");
                                   }

                                   // Создаем клиента
                                   Client client = new Client();
                                   client.setPhone(request.getPhone());
                                   client.setFullName(request.getFullName());
                                   client.setAge(request.getAge());
                                   client.setPhotoUrl(request.getPhotoUrl());
                                   client.setPsychologist(invite.getPsychologist());
                                   client.setLinkedAt(LocalDateTime.now());
                                   client.setRole(UserRole.ROLE_CLIENT);

                                   clientRepository.save(client);

                                   // Помечаем инвайт как использованный
                                   invite.setUsed(true);
                                   invite.setUsedAt(LocalDateTime.now());
                                   inviteRepository.save(invite);

                                   return generateAuthResponse(client);
                               }


                               public void logout(String accessToken, String refreshToken) {
                                   // Добавляем токены в черный список
                                   if (accessToken != null) {
                                       // Добавляем access token в черный список на 30 минут
                                       stringRedisTemplate.opsForValue().set(
                                               BLACKLIST_PREFIX + accessToken,
                                               "blacklisted",
                                               30, // 30 минут
                                               java.util.concurrent.TimeUnit.MINUTES
                                       );
                                   }

                                   if (refreshToken != null) {
                                       // Удаляем refresh token из валидных
                                       String phone = jwtTokenProvider.extractUsername(refreshToken);
                                       stringRedisTemplate.delete(REFRESH_PREFIX + phone);
                                   }
                               }

                               private AuthResponse generateAuthResponse(com.psychology.model.entity.User user) {
                                   // Создаем UserDetails для генерации токена
                                   UserDetails userDetails = org.springframework.security.core.userdetails.User
                                           .withUsername(user.getPhone())
                                           .password("") // Пароль не используется
                                           .roles(user.getRole().name().replace("ROLE_", ""))
                                           .build();

                                   String accessToken = jwtTokenProvider.generateAccessToken(userDetails);
                                   String refreshToken = jwtTokenProvider.generateRefreshToken(userDetails);

                                   // Сохраняем refresh token в Redis
                                   stringRedisTemplate.opsForValue().set(
                                           REFRESH_PREFIX + user.getPhone(),
                                           refreshToken,
                                           7, // 7 дней
                                           java.util.concurrent.TimeUnit.DAYS
                                   );

                                   AuthResponse response = new AuthResponse();
                                   response.setAccessToken(accessToken);
                                   response.setRefreshToken(refreshToken);
                                   response.setUserId(user.getId());
                                   response.setUserRole(user.getRole().name());
                                   response.setFullName(getFullName(user));
                                   response.setPhone(user.getPhone());

                                   return response;
                               }

                               private String getFullName(com.psychology.model.entity.User user) {
                                   if (user instanceof Psychologist) {
                                       return ((Psychologist) user).getFullName();
                                   } else if (user instanceof Client) {
                                       return ((Client) user).getFullName();
                                   }
                                   return "";
                               }
                           }package com.psychology.service;

                            import com.psychology.dto.ChatDTO;
                            import com.psychology.model.entity.Message;
                            import com.psychology.model.entity.User;
                            import com.psychology.model.entity.Psychologist;
                            import com.psychology.model.entity.Client;
                            import com.psychology.repository.MessageRepository;
                            import com.psychology.repository.UserRepository;
                            import lombok.RequiredArgsConstructor;
                            import lombok.extern.slf4j.Slf4j;
                            import org.springframework.messaging.simp.SimpMessagingTemplate;
                            import org.springframework.stereotype.Service;
                            import org.springframework.transaction.annotation.Transactional;

                            import java.time.LocalDateTime;
                            import java.util.List;
                            import java.util.stream.Collectors;

                            @Service
                            @RequiredArgsConstructor
                            @Slf4j
                            public class ChatService {

                                private final MessageRepository messageRepository;
                                private final UserRepository userRepository;
                                private final SimpMessagingTemplate messagingTemplate;
                                private final NotificationService notificationService; // Добавляем зависимость

                                @Transactional
                                public ChatDTO.MessageResponse sendMessage(User sender, ChatDTO.SendMessageRequest request) {
                                    log.info("Sending message from {} to {}", sender.getId(), request.getReceiverId());

                                    // Проверяем, что получатель существует
                                    User receiver = userRepository.findById(request.getReceiverId())
                                            .orElseThrow(() -> new RuntimeException("Receiver not found"));

                                    // Проверяем, что можно отправлять сообщения
                                    if (!canSendMessage(sender, receiver)) {
                                        throw new RuntimeException("Cannot send message to this user");
                                    }

                                    // Проверяем длину сообщения (макс 2000 символов по ТЗ)
                                    if (request.getContent().length() > 2000) {
                                        throw new RuntimeException("Message too long. Maximum 2000 characters");
                                    }

                                    // Сохраняем сообщение
                                    Message message = new Message();
                                    message.setSender(sender);
                                    message.setReceiver(receiver);
                                    message.setContent(request.getContent());
                                    message.setAttachmentUrl(request.getAttachmentUrl());
                                    message.setSentAt(LocalDateTime.now());

                                    messageRepository.save(message);

                                    // Создаем DTO для ответа
                                    ChatDTO.MessageResponse response = convertToDTO(message);

                                    // Отправляем уведомление через NotificationService
                                    notificationService.sendNewMessageNotification(response);

                                    log.info("Message sent successfully. ID: {}", message.getId());
                                    return response;
                                }

                                @Transactional(readOnly = true)
                                public List<ChatDTO.MessageResponse> getConversation(User currentUser, Long otherUserId) {
                                    log.info("Getting conversation between {} and {}", currentUser.getId(), otherUserId);

                                    // Проверяем, что другой пользователь существует
                                    User otherUser = userRepository.findById(otherUserId)
                                            .orElseThrow(() -> new RuntimeException("User not found"));

                                    // Проверяем, что можно видеть переписку
                                    if (!canSeeConversation(currentUser, otherUser)) {
                                        throw new RuntimeException("Cannot access this conversation");
                                    }

                                    List<Message> messages = messageRepository.findConversation(currentUser.getId(), otherUserId);

                                    return messages.stream()
                                            .map(this::convertToDTO)
                                            .collect(Collectors.toList());
                                }

                                @Transactional(readOnly = true)
                                public List<ChatDTO.MessageResponse> getRecentMessages(User user, LocalDateTime since) {
                                    log.info("Getting recent messages for user {} since {}", user.getId(), since);

                                    List<Message> messages = messageRepository.findRecentMessages(user.getId(), since);

                                    return messages.stream()
                                            .map(this::convertToDTO)
                                            .collect(Collectors.toList());
                                }

                                @Transactional
                                public void markAsRead(User user, Long messageId) {
                                    log.info("Marking message {} as read by user {}", messageId, user.getId());

                                    Message message = messageRepository.findById(messageId)
                                            .orElseThrow(() -> new RuntimeException("Message not found"));

                                    // Проверяем, что пользователь - получатель сообщения
                                    if (!message.getReceiver().getId().equals(user.getId())) {
                                        throw new RuntimeException("Cannot mark this message as read");
                                    }

                                    message.setRead(true);
                                    messageRepository.save(message);
                                }

                                @Transactional(readOnly = true)
                                public Long getUnreadCount(User user) {
                                    return messageRepository.countByReceiverIdAndReadFalse(user.getId());
                                }

                                @Transactional(readOnly = true)
                                public List<ChatDTO.MessageResponse> getUnreadMessages(User user) {
                                    List<Message> messages = messageRepository.findUnreadMessages(user.getId());

                                    return messages.stream()
                                            .map(this::convertToDTO)
                                            .collect(Collectors.toList());
                                }

                                private boolean canSendMessage(User sender, User receiver) {
                                    // Психолог может писать только своим клиентам и наоборот
                                    if (sender instanceof Psychologist && receiver instanceof Client) {
                                        Client client = (Client) receiver;
                                        return client.getPsychologist().getId().equals(sender.getId());
                                    } else if (sender instanceof Client && receiver instanceof Psychologist) {
                                        Client client = (Client) sender;
                                        return client.getPsychologist().getId().equals(receiver.getId());
                                    }
                                    return false;
                                }

                                private boolean canSeeConversation(User user1, User user2) {
                                    // Тот же принцип: видеть переписку могут только связанные психолог-клиент
                                    if (user1 instanceof Psychologist && user2 instanceof Client) {
                                        Client client = (Client) user2;
                                        return client.getPsychologist().getId().equals(user1.getId());
                                    } else if (user1 instanceof Client && user2 instanceof Psychologist) {
                                        Client client = (Client) user1;
                                        return client.getPsychologist().getId().equals(user2.getId());
                                    }
                                    return false;
                                }

                                private ChatDTO.MessageResponse convertToDTO(Message message) {
                                    ChatDTO.MessageResponse dto = new ChatDTO.MessageResponse();
                                    dto.setId(message.getId());
                                    dto.setSenderId(message.getSender().getId());
                                    dto.setSenderName(getUserName(message.getSender()));
                                    dto.setSenderRole(message.getSender().getRole().name());
                                    dto.setReceiverId(message.getReceiver().getId());
                                    dto.setReceiverName(getUserName(message.getReceiver()));
                                    dto.setContent(message.getContent());
                                    dto.setAttachmentUrl(message.getAttachmentUrl());
                                    dto.setRead(message.isRead());
                                    dto.setSentAt(message.getSentAt());
                                    return dto;
                                }

                                private String getUserName(User user) {
                                    if (user instanceof Psychologist) {
                                        return ((Psychologist) user).getFullName();
                                    } else if (user instanceof Client) {
                                        return ((Client) user).getFullName();
                                    }
                                    return "Unknown";
                                }
                            }package com.psychology.service;

                             import com.psychology.controller.ClientManagementController.*;
                             import com.psychology.model.entity.*;
                             import com.psychology.repository.*;
                             import lombok.RequiredArgsConstructor;
                             import org.springframework.stereotype.Service;

                             import java.time.LocalDateTime;
                             import java.util.ArrayList;
                             import java.util.Comparator;
                             import java.util.List;
                             import java.util.stream.Collectors;

                             @Service
                             @RequiredArgsConstructor
                             public class ClientManagementService {

                                 private final ClientRepository clientRepository;
                                 private final SessionRepository sessionRepository;
                                 private final JournalEntryRepository journalEntryRepository;
                                 private final RecommendationRepository recommendationRepository;
                                 private final MessageRepository messageRepository;

                                 public List<Client> getAllClients(Psychologist psychologist) {
                                     return clientRepository.findByPsychologistId(psychologist.getId());
                                 }

                                 public Client getClient(Psychologist psychologist, Long clientId) {
                                     Client client = clientRepository.findById(clientId)
                                             .orElseThrow(() -> new RuntimeException("Client not found"));

                                     if (!client.getPsychologist().getId().equals(psychologist.getId())) {
                                         throw new RuntimeException("Client does not belong to this psychologist");
                                     }

                                     return client;
                                 }

                                 public List<Client> searchClients(Psychologist psychologist, String query) {
                                     List<Client> allClients = clientRepository.findByPsychologistId(psychologist.getId());

                                     if (query == null || query.trim().isEmpty()) {
                                         return allClients;
                                     }

                                     String searchQuery = query.toLowerCase().trim();

                                     return allClients.stream()
                                             .filter(client ->
                                                     client.getFullName().toLowerCase().contains(searchQuery) ||
                                                             (client.getPhone() != null && client.getPhone().contains(searchQuery))
                                             )
                                             .collect(Collectors.toList());
                                 }

                                 public ClientStats getClientStats(Psychologist psychologist, Long clientId,
                                                                   LocalDateTime from, LocalDateTime to) {
                                     Client client = getClient(psychologist, clientId);

                                     ClientStats stats = new ClientStats();

                                     // Сеансы
                                     List<Session> sessions = (from != null && to != null) ?
                                             sessionRepository.findByClientIdAndScheduledAtBetween(clientId, from, to) :
                                             sessionRepository.findByClientIdOrderByScheduledAtDesc(clientId);

                                     stats.setTotalSessions(sessions.size());
                                     stats.setCompletedSessions((long) sessions.stream()
                                             .filter(s -> s.getStatus() == Session.SessionStatus.COMPLETED)
                                             .count());
                                     stats.setCancelledSessions((long) sessions.stream()
                                             .filter(s -> s.getStatus() == Session.SessionStatus.CANCELLED)
                                             .count());

                                     // Процент посещаемости
                                     long scheduledSessions = sessions.stream()
                                             .filter(s -> s.getStatus() == Session.SessionStatus.SCHEDULED ||
                                                     s.getStatus() == Session.SessionStatus.CONFIRMED)
                                             .count();
                                     long attendedSessions = sessions.stream()
                                             .filter(s -> s.getStatus() == Session.SessionStatus.COMPLETED)
                                             .count();

                                     if (scheduledSessions > 0) {
                                         stats.setAttendanceRate((double) attendedSessions / scheduledSessions * 100);
                                     } else {
                                         stats.setAttendanceRate(0);
                                     }

                                     // Записи в дневнике
                                     List<JournalEntry> journalEntries = (from != null && to != null) ?
                                             journalEntryRepository.findByClientId(clientId).stream()
                                                     .filter(e -> !e.getCreatedAt().isBefore(from) && !e.getCreatedAt().isAfter(to))
                                                     .collect(Collectors.toList()) :
                                             journalEntryRepository.findByClientIdOrderByCreatedAtDesc(clientId);

                                     stats.setJournalEntries(journalEntries.size());

                                     // Рекомендации
                                     List<Recommendation> recommendations = recommendationRepository.findByClientId(clientId);
                                     stats.setActiveRecommendations(recommendations.stream()
                                             .filter(r -> !r.isCompleted())
                                             .count());
                                     stats.setCompletedRecommendations(recommendations.stream()
                                             .filter(Recommendation::isCompleted)
                                             .count());

                                     return stats;
                                 }

                                 public ClientActivity getClientActivity(Psychologist psychologist, Long clientId, int days) {
                                     Client client = getClient(psychologist, clientId);

                                     ClientActivity activity = new ClientActivity();
                                     LocalDateTime since = LocalDateTime.now().minusDays(days);

                                     // Недавние сеансы
                                     List<Session> recentSessions = sessionRepository.findByClientIdOrderByScheduledAtDesc(clientId)
                                             .stream()
                                             .filter(s -> s.getScheduledAt().isAfter(since))
                                             .limit(10)
                                             .collect(Collectors.toList());

                                     activity.setRecentSessions(recentSessions.stream()
                                             .map(session -> {
                                                 SessionActivity sa = new SessionActivity();
                                                 sa.setDate(session.getScheduledAt());
                                                 sa.setStatus(session.getStatus().name());
                                                 sa.setDescription(session.getDescription());
                                                 return sa;
                                             })
                                             .collect(Collectors.toList()));

                                     // Недавние записи в дневнике
                                     List<JournalEntry> recentJournalEntries = journalEntryRepository.findByClientIdOrderByCreatedAtDesc(clientId)
                                             .stream()
                                             .filter(e -> e.getCreatedAt().isAfter(since))
                                             .limit(10)
                                             .collect(Collectors.toList());

                                     activity.setRecentJournalEntries(recentJournalEntries.stream()
                                             .map(entry -> {
                                                 JournalActivity ja = new JournalActivity();
                                                 ja.setDate(entry.getCreatedAt());
                                                 ja.setMood(entry.getMood());
                                                 ja.setEntryLength(entry.getContent().length());
                                                 return ja;
                                             })
                                             .collect(Collectors.toList()));

                                     // Недавние рекомендации
                                     List<Recommendation> recentRecommendations = recommendationRepository.findByClientId(clientId)
                                             .stream()
                                             .filter(r -> r.getCreatedAt().isAfter(since))
                                             .sorted(Comparator.comparing(Recommendation::getCreatedAt).reversed())
                                             .limit(10)
                                             .collect(Collectors.toList());

                                     activity.setRecentRecommendations(recentRecommendations.stream()
                                             .map(rec -> {
                                                 RecommendationActivity ra = new RecommendationActivity();
                                                 ra.setDate(rec.getCreatedAt());
                                                 ra.setTitle(rec.getTitle());
                                                 ra.setCompleted(rec.isCompleted());
                                                 return ra;
                                             })
                                             .collect(Collectors.toList()));

                                     // Активность в чате
                                     MessageActivity messageActivity = new MessageActivity();
                                     List<Message> messages = messageRepository.findAllUserMessages(clientId)
                                             .stream()
                                             .filter(m -> m.getSentAt().isAfter(since))
                                             .collect(Collectors.toList());

                                     messageActivity.setTotalMessages(messages.size());
                                     messageActivity.setUnreadMessages(messages.stream()
                                             .filter(m -> !m.isRead() && m.getReceiver().getId().equals(clientId))
                                             .count());

                                     messages.stream()
                                             .max(Comparator.comparing(Message::getSentAt))
                                             .ifPresent(lastMessage -> messageActivity.setLastMessageDate(lastMessage.getSentAt()));

                                     activity.setMessageActivity(messageActivity);

                                     return activity;
                                 }
                             }package com.psychology.service;

                              import lombok.RequiredArgsConstructor;
                              import lombok.extern.slf4j.Slf4j;
                              import org.springframework.beans.factory.annotation.Value;
                              import org.springframework.stereotype.Service;
                              import org.springframework.web.multipart.MultipartFile;

                              import java.io.IOException;
                              import java.nio.file.Files;
                              import java.nio.file.Path;
                              import java.nio.file.Paths;
                              import java.util.UUID;

                              @Service
                              @RequiredArgsConstructor
                              @Slf4j
                              public class FileStorageService {

                                  @Value("${file.upload-dir:uploads}")
                                  private String uploadDir;

                                  public String storeFile(MultipartFile file) throws IOException {
                                      // Проверяем размер файла
                                      if (file.getSize() > 5 * 1024 * 1024) { // 5MB
                                          throw new RuntimeException("File size exceeds 5MB limit");
                                      }

                                      // Проверяем тип файла
                                      String contentType = file.getContentType();
                                      if (!isAllowedFileType(contentType)) {
                                          throw new RuntimeException("File type not allowed. Allowed: images, PDF, DOC, DOCX");
                                      }

                                      // Создаем директорию, если не существует
                                      Path uploadPath = Paths.get(uploadDir);
                                      if (!Files.exists(uploadPath)) {
                                          Files.createDirectories(uploadPath);
                                      }

                                      // Генерируем уникальное имя файла
                                      String originalFileName = file.getOriginalFilename();
                                      String fileExtension = originalFileName.substring(originalFileName.lastIndexOf("."));
                                      String fileName = UUID.randomUUID().toString() + fileExtension;

                                      // Сохраняем файл
                                      Path filePath = uploadPath.resolve(fileName);
                                      Files.copy(file.getInputStream(), filePath);

                                      // Возвращаем относительный путь
                                      return "/uploads/" + fileName;
                                  }

                                  private boolean isAllowedFileType(String contentType) {
                                      return contentType != null && (
                                              contentType.startsWith("image/") ||
                                                      contentType.equals("application/pdf") ||
                                                      contentType.equals("application/msword") ||
                                                      contentType.equals("application/vnd.openxmlformats-officedocument.wordprocessingml.document")
                                      );
                                  }

                                  public byte[] loadFile(String fileName) throws IOException {
                                      Path filePath = Paths.get(uploadDir).resolve(fileName);
                                      return Files.readAllBytes(filePath);
                                  }
                              }package com.psychology.service;

                               import com.psychology.controller.InviteController.InviteDTO;
                               import com.psychology.controller.InviteController.InviteValidationResponse;
                               import com.psychology.model.entity.Invite;
                               import com.psychology.model.entity.Psychologist;
                               import com.psychology.repository.InviteRepository;
                               import com.psychology.repository.PsychologistRepository;
                               import lombok.RequiredArgsConstructor;
                               import lombok.extern.slf4j.Slf4j;
                               import org.apache.commons.lang3.RandomStringUtils;
                               import org.springframework.stereotype.Service;
                               import org.springframework.transaction.annotation.Transactional;

                               import java.time.LocalDateTime;
                               import java.time.format.DateTimeFormatter;
                               import java.util.List;
                               import java.util.stream.Collectors;

                               @Service
                               @RequiredArgsConstructor
                               @Slf4j
                               public class InviteService {
                                   private final InviteRepository inviteRepository;
                                   private final PsychologistRepository psychologistRepository;

                                   private static final int INVITE_TOKEN_LENGTH = 32;
                                   private static final DateTimeFormatter FORMATTER = DateTimeFormatter.ISO_LOCAL_DATE_TIME;

                                   @Transactional
                                   public String createInvite(Psychologist psychologist) {
                                       log.info("Creating invite for psychologist ID: {}", psychologist.getId());

                                       // Загружаем психолога из базы
                                       Psychologist managedPsychologist = psychologistRepository.findById(psychologist.getId())
                                               .orElseThrow(() -> {
                                                   log.error("Psychologist not found with ID: {}", psychologist.getId());
                                                   return new RuntimeException("Psychologist not found");
                                               });

                                       log.info("Loaded psychologist: ID={}, Name={}, Verified={}",
                                               managedPsychologist.getId(),
                                               managedPsychologist.getFullName(),
                                               managedPsychologist.isVerified());

                                       String token;
                                       int attempts = 0;
                                       do {
                                           token = RandomStringUtils.randomAlphanumeric(INVITE_TOKEN_LENGTH);
                                           attempts++;
                                           if (attempts > 10) {
                                               throw new RuntimeException("Failed to generate unique token after 10 attempts");
                                           }
                                       } while (inviteRepository.existsByToken(token));

                                       Invite invite = new Invite();
                                       invite.setToken(token);
                                       invite.setPsychologist(managedPsychologist);
                                       invite.setCreatedAt(LocalDateTime.now());
                                       invite.setExpiresAt(LocalDateTime.now().plusDays(7));
                                       invite.setUsed(false);

                                       try {
                                           inviteRepository.save(invite);
                                           log.info("Invite created successfully. Token: {}, Psychologist ID: {}",
                                                   token, managedPsychologist.getId());
                                       } catch (Exception e) {
                                           log.error("Error saving invite: {}", e.getMessage(), e);
                                           throw new RuntimeException("Failed to save invite: " + e.getMessage());
                                       }

                                       return token;
                                   }

                                   public List<InviteDTO> getInvitesByPsychologist(Long psychologistId) {
                                       log.info("Getting invites for psychologist ID: {}", psychologistId);

                                       List<Invite> invites = inviteRepository.findByPsychologistIdAndUsedFalse(psychologistId);

                                       return invites.stream()
                                               .map(invite -> new InviteDTO(
                                                       invite.getToken(),
                                                       invite.getCreatedAt().format(FORMATTER),
                                                       invite.getExpiresAt().format(FORMATTER),
                                                       invite.isUsed()
                                               ))
                                               .collect(Collectors.toList());
                                   }

                                   @Transactional(readOnly = true) // Добавляем транзакцию для чтения
                                   public InviteValidationResponse validateInvite(String token) {
                                       log.info("Validating invite token: {}", token);

                                       // Используем кастомный запрос для загрузки psychologist сразу
                                       Invite invite = inviteRepository.findByTokenWithPsychologist(token)
                                               .orElseThrow(() -> {
                                                   log.error("Invite not found for token: {}", token);
                                                   return new RuntimeException("Invite not found");
                                               });

                                       boolean valid = !invite.isUsed() && invite.getExpiresAt().isAfter(LocalDateTime.now());

                                       // Теперь psychologist должен быть загружен
                                       String psychologistName = invite.getPsychologist().getFullName();
                                       String expiresAt = invite.getExpiresAt().format(FORMATTER);

                                       log.info("Invite validation result: valid={}, psychologist={}", valid, psychologistName);

                                       return new InviteValidationResponse(valid, psychologistName, expiresAt);
                                   }
                               }package com.psychology.service;

                                import com.psychology.controller.JournalController.JournalEntryRequest;
                                import com.psychology.controller.JournalController.JournalStats;
                                import com.psychology.model.entity.JournalEntry;
                                import com.psychology.model.entity.Client;
                                import com.psychology.repository.JournalEntryRepository;
                                import com.psychology.repository.ClientRepository;
                                import lombok.RequiredArgsConstructor;
                                import lombok.extern.slf4j.Slf4j;
                                import org.springframework.data.domain.PageRequest;
                                import org.springframework.data.domain.Pageable;
                                import org.springframework.data.domain.Sort;
                                import org.springframework.stereotype.Service;
                                import org.springframework.transaction.annotation.Transactional;

                                import java.time.LocalDate;
                                import java.time.LocalDateTime;
                                import java.util.*;
                                import java.util.stream.Collectors;

                                @Service
                                @RequiredArgsConstructor
                                @Slf4j
                                public class JournalService {

                                    private final JournalEntryRepository journalEntryRepository;
                                    private final ClientRepository clientRepository;

                                    private static final int MAX_CONTENT_LENGTH = 5000;
                                    private static final int MAX_ENTRIES_PER_DAY = 10;

                                    @Transactional
                                    public JournalEntry createEntry(Client client, JournalEntryRequest request) {
                                        validateContent(request.getContent());

                                        // Проверяем лимит записей в день
                                        LocalDateTime startOfDay = LocalDate.now().atStartOfDay();
                                        LocalDateTime endOfDay = startOfDay.plusDays(1);
                                        long entriesToday = journalEntryRepository.countByClientIdAndCreatedAtBetween(
                                                client.getId(), startOfDay, endOfDay);

                                        if (entriesToday >= MAX_ENTRIES_PER_DAY) {
                                            throw new RuntimeException("Daily limit of " + MAX_ENTRIES_PER_DAY + " entries reached");
                                        }

                                        JournalEntry entry = new JournalEntry();
                                        entry.setClient(client);
                                        entry.setContent(request.getContent());
                                        entry.setMood(request.getMood());
                                        entry.setTags(request.getTags() != null ? request.getTags() : new ArrayList<>());
                                        entry.setCreatedAt(LocalDateTime.now());

                                        return journalEntryRepository.save(entry);
                                    }

                                    public List<JournalEntry> getClientEntries(Long clientId, int page, int size) {
                                        Pageable pageable = PageRequest.of(page, size, Sort.by(Sort.Direction.DESC, "createdAt"));
                                        return journalEntryRepository.findByClientId(clientId, pageable);
                                    }

                                    public JournalEntry getClientEntry(Long clientId, Long entryId) {
                                        JournalEntry entry = journalEntryRepository.findById(entryId)
                                                .orElseThrow(() -> new RuntimeException("Journal entry not found"));

                                        if (!entry.getClient().getId().equals(clientId)) {
                                            throw new RuntimeException("Access denied");
                                        }

                                        return entry;
                                    }

                                    @Transactional
                                    public JournalEntry updateEntry(Long clientId, Long entryId, JournalEntryRequest request) {
                                        JournalEntry entry = getClientEntry(clientId, entryId);

                                        if (request.getContent() != null) {
                                            validateContent(request.getContent());
                                            entry.setContent(request.getContent());
                                        }
                                        if (request.getMood() != null) {
                                            entry.setMood(request.getMood());
                                        }
                                        if (request.getTags() != null) {
                                            entry.setTags(request.getTags());
                                        }

                                        return journalEntryRepository.save(entry);
                                    }

                                    @Transactional
                                    public void deleteEntry(Long clientId, Long entryId) {
                                        JournalEntry entry = getClientEntry(clientId, entryId);
                                        journalEntryRepository.delete(entry);
                                    }

                                    public List<JournalEntry> getClientEntriesForPsychologist(Long psychologistId, Long clientId, int page, int size) {
                                        // Проверяем, что клиент принадлежит психологу
                                        Client client = clientRepository.findById(clientId)
                                                .orElseThrow(() -> new RuntimeException("Client not found"));

                                        if (!client.getPsychologist().getId().equals(psychologistId)) {
                                            throw new RuntimeException("Client does not belong to this psychologist");
                                        }

                                        Pageable pageable = PageRequest.of(page, size, Sort.by(Sort.Direction.DESC, "createdAt"));
                                        return journalEntryRepository.findByClientId(clientId, pageable);
                                    }

                                    public JournalEntry getClientEntryForPsychologist(Long psychologistId, Long clientId, Long entryId) {
                                        // Сначала проверяем доступ психолога к клиенту
                                        getClientEntriesForPsychologist(psychologistId, clientId, 0, 1);

                                        // Затем получаем запись
                                        return getClientEntry(clientId, entryId);
                                    }

                                    public List<JournalEntry> searchEntriesByTag(Long clientId, String tag) {
                                        List<JournalEntry> allEntries = journalEntryRepository.findByClientIdOrderByCreatedAtDesc(clientId);
                                        return allEntries.stream()
                                                .filter(entry -> entry.getTags() != null && entry.getTags().contains(tag))
                                                .collect(Collectors.toList());
                                    }

                                    public JournalStats getJournalStats(Long clientId) {
                                        List<JournalEntry> entries = journalEntryRepository.findByClientIdOrderByCreatedAtDesc(clientId);

                                        if (entries.isEmpty()) {
                                            JournalStats stats = new JournalStats();
                                            stats.setTotalEntries(0);
                                            stats.setEntriesThisMonth(0);
                                            stats.setMostCommonMood("No entries yet");
                                            stats.setMostUsedTags(new ArrayList<>());
                                            return stats;
                                        }

                                        // Подсчет статистики
                                        JournalStats stats = new JournalStats();
                                        stats.setTotalEntries(entries.size());

                                        // Записи за текущий месяц
                                        LocalDateTime startOfMonth = LocalDate.now().withDayOfMonth(1).atStartOfDay();
                                        long entriesThisMonth = entries.stream()
                                                .filter(e -> e.getCreatedAt().isAfter(startOfMonth))
                                                .count();
                                        stats.setEntriesThisMonth(entriesThisMonth);

                                        // Самое частое настроение
                                        Map<String, Long> moodCount = entries.stream()
                                                .filter(e -> e.getMood() != null && !e.getMood().trim().isEmpty())
                                                .collect(Collectors.groupingBy(JournalEntry::getMood, Collectors.counting()));

                                        String mostCommonMood = moodCount.entrySet().stream()
                                                .max(Map.Entry.comparingByValue())
                                                .map(Map.Entry::getKey)
                                                .orElse("Not specified");
                                        stats.setMostCommonMood(mostCommonMood);

                                        // Самые используемые теги
                                        Map<String, Long> tagCount = entries.stream()
                                                .filter(e -> e.getTags() != null)
                                                .flatMap(e -> e.getTags().stream())
                                                .collect(Collectors.groupingBy(tag -> tag, Collectors.counting()));

                                        List<String> mostUsedTags = tagCount.entrySet().stream()
                                                .sorted((e1, e2) -> e2.getValue().compareTo(e1.getValue()))
                                                .limit(5)
                                                .map(Map.Entry::getKey)
                                                .collect(Collectors.toList());
                                        stats.setMostUsedTags(mostUsedTags);

                                        return stats;
                                    }

                                    @Transactional
                                    public void cleanupOldEntries() {
                                        LocalDateTime threeYearsAgo = LocalDateTime.now().minusYears(3);
                                        List<JournalEntry> oldEntries = journalEntryRepository.findByCreatedAtBefore(threeYearsAgo);

                                        if (!oldEntries.isEmpty()) {
                                            log.info("Cleaning up {} old journal entries", oldEntries.size());
                                            journalEntryRepository.deleteAll(oldEntries);
                                        }
                                    }

                                    private void validateContent(String content) {
                                        if (content == null || content.trim().isEmpty()) {
                                            throw new RuntimeException("Content cannot be empty");
                                        }
                                        if (content.length() > MAX_CONTENT_LENGTH) {
                                            throw new RuntimeException("Content exceeds maximum length of " + MAX_CONTENT_LENGTH + " characters");
                                        }
                                    }
                                }package com.psychology.service;

                                 import com.psychology.dto.ChatDTO;
                                 import com.psychology.dto.TypingNotificationDTO;
                                 import com.psychology.model.entity.Notification;
                                 import com.psychology.model.entity.User;
                                 import com.psychology.repository.NotificationRepository;
                                 import lombok.RequiredArgsConstructor;
                                 import lombok.extern.slf4j.Slf4j;
                                 import org.springframework.data.domain.PageRequest;
                                 import org.springframework.data.domain.Pageable;
                                 import org.springframework.data.domain.Sort;
                                 import org.springframework.messaging.simp.SimpMessagingTemplate;
                                 import org.springframework.stereotype.Service;
                                 import org.springframework.transaction.annotation.Transactional;

                                 import java.time.LocalDateTime;
                                 import java.util.List;

                                 @Service
                                 @RequiredArgsConstructor
                                 @Slf4j
                                 public class NotificationService {

                                     private final NotificationRepository notificationRepository;
                                     private final SimpMessagingTemplate messagingTemplate;

                                     @Transactional
                                     public Notification createNotification(User user, Notification.NotificationType type,
                                                                            String title, String message) {
                                         return createNotification(user, type, title, message, null, null);
                                     }

                                     @Transactional
                                     public Notification createNotification(User user, Notification.NotificationType type,
                                                                            String title, String message,
                                                                            Long relatedEntityId, String relatedEntityType) {
                                         Notification notification = new Notification();
                                         notification.setUser(user);
                                         notification.setType(type);
                                         notification.setTitle(title);
                                         notification.setMessage(message);
                                         notification.setRead(false);
                                         notification.setRelatedEntityId(relatedEntityId);
                                         notification.setRelatedEntityType(relatedEntityType);
                                         notification.setCreatedAt(LocalDateTime.now());

                                         Notification saved = notificationRepository.save(notification);

                                         // Отправляем уведомление через WebSocket
                                         sendRealTimeNotification(user, saved);

                                         return saved;
                                     }

                                     public List<Notification> getUserNotifications(User user, int page, int size) {
                                         Pageable pageable = PageRequest.of(page, size, Sort.by(Sort.Direction.DESC, "createdAt"));
                                         return notificationRepository.findByUser(user, pageable);
                                     }

                                     public List<Notification> getUnreadNotifications(User user) {
                                         return notificationRepository.findByUserAndReadOrderByCreatedAtDesc(user, false);
                                     }

                                     public long getUnreadCount(User user) {
                                         return notificationRepository.countByUserAndRead(user, false);
                                     }

                                     @Transactional
                                     public void markAsRead(Long notificationId, User user) {
                                         Notification notification = notificationRepository.findById(notificationId)
                                                 .orElseThrow(() -> new RuntimeException("Notification not found"));

                                         if (!notification.getUser().getId().equals(user.getId())) {
                                             throw new RuntimeException("Notification does not belong to this user");
                                         }

                                         notification.setRead(true);
                                         notificationRepository.save(notification);
                                     }

                                     @Transactional
                                     public void markAllAsRead(User user) {
                                         notificationRepository.markAllAsReadByUser(user);
                                     }

                                     @Transactional
                                     public void deleteNotification(Long notificationId, User user) {
                                         Notification notification = notificationRepository.findById(notificationId)
                                                 .orElseThrow(() -> new RuntimeException("Notification not found"));

                                         if (!notification.getUser().getId().equals(user.getId())) {
                                             throw new RuntimeException("Notification does not belong to this user");
                                         }

                                         notificationRepository.delete(notification);
                                     }
                                     public void sendNewMessageNotification(ChatDTO.MessageResponse message) {
                                         // Создаем уведомление в базе данных
                                         // Для этого нам нужен получатель, но у нас только его ID
                                         // Мы не можем создать Notification без объекта User

                                         // Вместо этого, отправляем через WebSocket напрямую
                                         String destination = "/user/" + message.getReceiverId() + "/queue/notifications";

                                         ChatDTO.ChatNotification notification = new ChatDTO.ChatNotification();
                                         notification.setMessageId(message.getId());
                                         notification.setSenderId(message.getSenderId());
                                         notification.setSenderName(message.getSenderName());
                                         notification.setContent(message.getContent());
                                         notification.setSentAt(message.getSentAt());

                                         messagingTemplate.convertAndSend(destination, notification);
                                         log.info("Sent new message notification to user {}: {}", message.getReceiverId(), message.getContent());
                                     }

                                     public void sendTypingNotification(Long senderId, Long receiverId, boolean isTyping) {
                                         String destination = "/user/" + receiverId + "/queue/typing";

                                         TypingNotificationDTO notification = new TypingNotificationDTO();
                                         notification.setSenderId(senderId);
                                         notification.setTyping(isTyping);

                                         messagingTemplate.convertAndSend(destination, notification);
                                         log.debug("Sent typing notification from {} to {}: {}", senderId, receiverId, isTyping);
                                     }

                                     public void sendMessageReadNotification(Long messageId, Long readerId) {
                                         String destination = "/queue/messages/read/" + messageId;
                                         messagingTemplate.convertAndSend(destination, readerId);
                                         log.debug("Sent message read notification for message {} by user {}", messageId, readerId);
                                     }

                                     @Transactional
                                     public void cleanupOldNotifications() {
                                         LocalDateTime expirationDate = LocalDateTime.now().minusMonths(6); // Храним 6 месяцев
                                         List<Notification> allNotifications = notificationRepository.findAll();
                                         List<User> users = allNotifications.stream()
                                                 .map(Notification::getUser)
                                                 .distinct()
                                                 .toList();

                                         for (User user : users) {
                                             notificationRepository.deleteOldNotifications(user, expirationDate);
                                         }
                                         log.info("Old notifications cleanup completed");
                                     }

                                     private void sendRealTimeNotification(User user, Notification notification) {
                                         String destination = "/user/" + user.getId() + "/queue/notifications";
                                         messagingTemplate.convertAndSend(destination, convertToDTO(notification));
                                         log.debug("Real-time notification sent to user {}: {}", user.getId(), notification.getTitle());
                                     }

                                     public NotificationDTO convertToDTO(Notification notification) {
                                         NotificationDTO dto = new NotificationDTO();
                                         dto.setId(notification.getId());
                                         dto.setType(notification.getType());
                                         dto.setTitle(notification.getTitle());
                                         dto.setMessage(notification.getMessage());
                                         dto.setRead(notification.isRead());
                                         dto.setRelatedEntityId(notification.getRelatedEntityId());
                                         dto.setRelatedEntityType(notification.getRelatedEntityType());
                                         dto.setCreatedAt(notification.getCreatedAt());
                                         return dto;
                                     }

                                     @lombok.Data
                                     public static class NotificationDTO {
                                         private Long id;
                                         private Notification.NotificationType type;
                                         private String title;
                                         private String message;
                                         private boolean read;
                                         private Long relatedEntityId;
                                         private String relatedEntityType;
                                         private LocalDateTime createdAt;
                                     }
                                 }package com.psychology.service;

                                  import lombok.RequiredArgsConstructor;
                                  import lombok.extern.slf4j.Slf4j;
                                  import org.apache.commons.lang3.RandomStringUtils;
                                  import org.springframework.data.redis.core.StringRedisTemplate;
                                  import org.springframework.stereotype.Service;

                                  import java.util.concurrent.TimeUnit;

                                  @Service
                                  @Slf4j
                                  @RequiredArgsConstructor
                                  public class OTPService {
                                      private final StringRedisTemplate stringRedisTemplate;

                                      private static final String OTP_PREFIX = "otp:";
                                      private static final String OTP_ATTEMPTS_PREFIX = "otp_attempts:";
                                      private static final String BLOCKED_PREFIX = "blocked:";
                                      private static final String SEND_TIMEOUT_PREFIX = "otp_timeout:";

                                      private static final int OTP_LENGTH = 6;
                                      private static final int OTP_TTL_MINUTES = 5;
                                      private static final int MAX_ATTEMPTS = 3;
                                      private static final int BLOCK_DURATION_MINUTES = 60;
                                      private static final int SEND_TIMEOUT_SECONDS = 60; // 1 minute

                                      public String generateOTP(String phone) {
                                          // Проверка блокировки
                                          if (isBlocked(phone)) {
                                              throw new RuntimeException("Phone is temporarily blocked");
                                          }

                                          // Проверка таймаута отправки
                                          String timeoutKey = SEND_TIMEOUT_PREFIX + phone;
                                          if (Boolean.TRUE.equals(stringRedisTemplate.hasKey(timeoutKey))) {
                                              throw new RuntimeException("Please wait before requesting new OTP");
                                          }

                                          // Генерация OTP
                                          String otp = RandomStringUtils.randomNumeric(OTP_LENGTH);
                                          String key = OTP_PREFIX + phone;

                                          // Сохранение в Redis
                                          stringRedisTemplate.opsForValue().set(
                                                  key,
                                                  otp,
                                                  OTP_TTL_MINUTES,
                                                  TimeUnit.MINUTES
                                          );

                                          // Установка таймаута на повторную отправку
                                          stringRedisTemplate.opsForValue().set(
                                                  timeoutKey,
                                                  "1",
                                                  SEND_TIMEOUT_SECONDS,
                                                  TimeUnit.SECONDS
                                          );

                                          // Логирование OTP (в продакшене будет отправка SMS)
                                          log.info("OTP for {}: {}", phone, otp);

                                          return otp;
                                      }

                                      public boolean verifyOTP(String phone, String otp) {
                                          String key = OTP_PREFIX + phone;
                                          String storedOtp = stringRedisTemplate.opsForValue().get(key);

                                          if (storedOtp == null) {
                                              return false;
                                          }

                                          boolean verified = storedOtp.equals(otp);

                                          if (verified) {
                                              // Удаляем OTP после успешной проверки
                                              stringRedisTemplate.delete(key);
                                              resetAttempts(phone);
                                          } else {
                                              incrementAttempts(phone);
                                          }

                                          return verified;
                                      }

                                      private void incrementAttempts(String phone) {
                                          String key = OTP_ATTEMPTS_PREFIX + phone;
                                          Long attempts = stringRedisTemplate.opsForValue().increment(key);

                                          if (attempts == 1) {
                                              stringRedisTemplate.expire(key, 1, TimeUnit.HOURS);
                                          }

                                          if (attempts >= MAX_ATTEMPTS) {
                                              blockPhone(phone);
                                              throw new RuntimeException("Too many OTP attempts");
                                          }
                                      }

                                      private void resetAttempts(String phone) {
                                          String key = OTP_ATTEMPTS_PREFIX + phone;
                                          stringRedisTemplate.delete(key);
                                      }

                                      private boolean isBlocked(String phone) {
                                          String key = BLOCKED_PREFIX + phone;
                                          return Boolean.TRUE.equals(stringRedisTemplate.hasKey(key));
                                      }

                                      private void blockPhone(String phone) {
                                          String key = BLOCKED_PREFIX + phone;
                                          stringRedisTemplate.opsForValue().set(key, "blocked", BLOCK_DURATION_MINUTES, TimeUnit.MINUTES);
                                      }
                                  }package com.psychology.service;

                                   import com.psychology.controller.ProfileController;
                                   import com.psychology.dto.PsychologistDTO;
                                   import com.psychology.model.entity.Psychologist;
                                   import com.psychology.model.entity.Client;
                                   import com.psychology.repository.PsychologistRepository;
                                   import com.psychology.repository.ClientRepository;
                                   import lombok.RequiredArgsConstructor;
                                   import org.springframework.stereotype.Service;
                                   import org.springframework.transaction.annotation.Transactional;

                                   @Service
                                   @RequiredArgsConstructor
                                   public class ProfileService {

                                       private final PsychologistRepository psychologistRepository;
                                       private final ClientRepository clientRepository;


                                       public Client getClientProfile(Client client) {
                                           return clientRepository.findById(client.getId())
                                                   .orElseThrow(() -> new RuntimeException("Client not found"));
                                       }
                                       public PsychologistDTO getPsychologistProfile(Psychologist psychologist) {
                                           Psychologist psych = psychologistRepository.findById(psychologist.getId())
                                                   .orElseThrow(() -> new RuntimeException("Psychologist not found"));

                                           return convertToDTO(psych);
                                       }

                                       private PsychologistDTO convertToDTO(Psychologist psychologist) {
                                           PsychologistDTO dto = new PsychologistDTO();
                                           dto.setId(psychologist.getId());
                                           dto.setPhone(psychologist.getPhone());
                                           dto.setFullName(psychologist.getFullName());
                                           dto.setEmail(psychologist.getEmail());
                                           dto.setEducation(psychologist.getEducation());
                                           dto.setSpecialization(psychologist.getSpecialization());
                                           dto.setDescription(psychologist.getDescription());
                                           dto.setPhotoUrl(psychologist.getPhotoUrl());
                                           dto.setVerified(psychologist.isVerified());
                                           dto.setVerifiedAt(psychologist.getVerifiedAt());
                                           dto.setCreatedAt(psychologist.getCreatedAt());

                                           return dto;
                                       }

                                       @Transactional
                                       public Psychologist updatePsychologistProfile(Psychologist psychologist,
                                                                                     ProfileController.PsychologistProfileUpdateRequest request) {
                                           Psychologist existingPsychologist = psychologistRepository.findById(psychologist.getId())
                                                   .orElseThrow(() -> new RuntimeException("Psychologist not found"));

                                           if (request.getFullName() != null && !request.getFullName().trim().isEmpty()) {
                                               existingPsychologist.setFullName(request.getFullName());
                                           }
                                           if (request.getEmail() != null && !request.getEmail().trim().isEmpty()) {
                                               existingPsychologist.setEmail(request.getEmail());
                                           }
                                           if (request.getEducation() != null) {
                                               existingPsychologist.setEducation(request.getEducation());
                                           }
                                           if (request.getSpecialization() != null) {
                                               existingPsychologist.setSpecialization(request.getSpecialization());
                                           }
                                           if (request.getDescription() != null) {
                                               existingPsychologist.setDescription(request.getDescription());
                                           }
                                           if (request.getPhotoUrl() != null) {
                                               existingPsychologist.setPhotoUrl(request.getPhotoUrl());
                                           }

                                           return psychologistRepository.save(existingPsychologist);
                                       }

                                       @Transactional
                                       public Client updateClientProfile(Client client,
                                                                         ProfileController.ClientProfileUpdateRequest request) {
                                           Client existingClient = clientRepository.findById(client.getId())
                                                   .orElseThrow(() -> new RuntimeException("Client not found"));

                                           if (request.getFullName() != null && !request.getFullName().trim().isEmpty()) {
                                               existingClient.setFullName(request.getFullName());
                                           }
                                           if (request.getAge() != null) {
                                               if (request.getAge() < 0 || request.getAge() > 120) {
                                                   throw new RuntimeException("Invalid age");
                                               }
                                               existingClient.setAge(request.getAge());
                                           }
                                           if (request.getPhotoUrl() != null) {
                                               existingClient.setPhotoUrl(request.getPhotoUrl());
                                           }

                                           return clientRepository.save(existingClient);
                                       }
                                   }package com.psychology.service;

                                    import com.psychology.controller.RecommendationController.RecommendationRequest;
                                    import com.psychology.controller.RecommendationController.RecommendationUpdateRequest;
                                    import com.psychology.controller.RecommendationController.RecommendationStats;
                                    import com.psychology.model.entity.Recommendation;
                                    import com.psychology.model.entity.Psychologist;
                                    import com.psychology.model.entity.Client;
                                    import com.psychology.repository.RecommendationRepository;
                                    import com.psychology.repository.ClientRepository;
                                    import lombok.RequiredArgsConstructor;
                                    import lombok.extern.slf4j.Slf4j;
                                    import org.springframework.stereotype.Service;
                                    import org.springframework.transaction.annotation.Transactional;

                                    import java.time.LocalDateTime;
                                    import java.util.ArrayList;
                                    import java.util.List;
                                    import java.util.stream.Collectors;

                                    @Service
                                    @RequiredArgsConstructor
                                    @Slf4j
                                    public class RecommendationService {

                                        private final RecommendationRepository recommendationRepository;
                                        private final ClientRepository clientRepository;
                                        private final NotificationService notificationService;

                                        @Transactional
                                        public Recommendation createRecommendation(Psychologist psychologist, RecommendationRequest request) {
                                            Client client = clientRepository.findById(request.getClientId())
                                                    .orElseThrow(() -> new RuntimeException("Client not found"));

                                            // Проверяем, что клиент принадлежит психологу
                                            if (!client.getPsychologist().getId().equals(psychologist.getId())) {
                                                throw new RuntimeException("Client does not belong to this psychologist");
                                            }

                                            Recommendation recommendation = new Recommendation();
                                            recommendation.setPsychologist(psychologist);
                                            recommendation.setClient(client);
                                            recommendation.setTitle(request.getTitle());
                                            recommendation.setContent(request.getContent());
                                            recommendation.setDeadline(request.getDeadline());
                                            recommendation.setPriority(request.getPriority() != null ? request.getPriority() : 3);
                                            recommendation.setCategories(request.getCategories());
                                            recommendation.setCompleted(false);
                                            recommendation.setCreatedAt(LocalDateTime.now());

                                            Recommendation saved = recommendationRepository.save(recommendation);

                                            // Создаем уведомление для клиента
                                            notificationService.createNotification(
                                                    client,
                                                    com.psychology.model.entity.Notification.NotificationType.NEW_RECOMMENDATION,
                                                    "Новая рекомендация",
                                                    String.format("У вас новая рекомендация от психолога: %s", request.getTitle())
                                            );

                                            return saved;
                                        }

                                        @Transactional
                                        public Recommendation updateRecommendation(Psychologist psychologist, Long recommendationId, RecommendationUpdateRequest request) {
                                            Recommendation recommendation = recommendationRepository.findById(recommendationId)
                                                    .orElseThrow(() -> new RuntimeException("Recommendation not found"));

                                            // Проверяем, что рекомендация принадлежит психологу
                                            if (!recommendation.getPsychologist().getId().equals(psychologist.getId())) {
                                                throw new RuntimeException("Recommendation does not belong to this psychologist");
                                            }

                                            if (request.getTitle() != null) {
                                                recommendation.setTitle(request.getTitle());
                                            }
                                            if (request.getContent() != null) {
                                                recommendation.setContent(request.getContent());
                                            }
                                            if (request.getDeadline() != null) {
                                                recommendation.setDeadline(request.getDeadline());
                                            }
                                            if (request.getPriority() != null) {
                                                recommendation.setPriority(request.getPriority());
                                            }
                                            if (request.getCompleted() != null) {
                                                recommendation.setCompleted(request.getCompleted());
                                                if (request.getCompleted()) {
                                                    recommendation.setCompletedAt(LocalDateTime.now());
                                                }
                                            }
                                            if (request.getCategories() != null) {
                                                recommendation.setCategories(request.getCategories());
                                            }

                                            return recommendationRepository.save(recommendation);
                                        }

                                        @Transactional
                                        public Recommendation completeRecommendation(Psychologist psychologist, Long recommendationId) {
                                            Recommendation recommendation = recommendationRepository.findById(recommendationId)
                                                    .orElseThrow(() -> new RuntimeException("Recommendation not found"));

                                            if (!recommendation.getPsychologist().getId().equals(psychologist.getId())) {
                                                throw new RuntimeException("Recommendation does not belong to this psychologist");
                                            }

                                            recommendation.setCompleted(true);
                                            recommendation.setCompletedAt(LocalDateTime.now());

                                            return recommendationRepository.save(recommendation);
                                        }

                                        @Transactional
                                        public Recommendation markAsCompletedByClient(Client client, Long recommendationId) {
                                            Recommendation recommendation = recommendationRepository.findById(recommendationId)
                                                    .orElseThrow(() -> new RuntimeException("Recommendation not found"));

                                            if (!recommendation.getClient().getId().equals(client.getId())) {
                                                throw new RuntimeException("Recommendation does not belong to this client");
                                            }

                                            recommendation.setCompleted(true);
                                            recommendation.setCompletedAt(LocalDateTime.now());
                                            recommendation.setCompletedByClient(true);

                                            return recommendationRepository.save(recommendation);
                                        }

                                        @Transactional
                                        public void deleteRecommendation(Psychologist psychologist, Long recommendationId) {
                                            Recommendation recommendation = recommendationRepository.findById(recommendationId)
                                                    .orElseThrow(() -> new RuntimeException("Recommendation not found"));

                                            if (!recommendation.getPsychologist().getId().equals(psychologist.getId())) {
                                                throw new RuntimeException("Recommendation does not belong to this psychologist");
                                            }

                                            recommendationRepository.delete(recommendation);
                                        }

                                        public List<Recommendation> getClientRecommendations(Psychologist psychologist, Long clientId,
                                                                                             Boolean completed, Boolean overdue,
                                                                                             LocalDateTime from, LocalDateTime to) {
                                            Client client = clientRepository.findById(clientId)
                                                    .orElseThrow(() -> new RuntimeException("Client not found"));

                                            if (!client.getPsychologist().getId().equals(psychologist.getId())) {
                                                throw new RuntimeException("Client does not belong to this psychologist");
                                            }

                                            List<Recommendation> recommendations = recommendationRepository.findByClientId(clientId);

                                            return filterRecommendations(recommendations, completed, overdue, from, to);
                                        }

                                        public List<Recommendation> getMyRecommendations(Client client, Boolean completed,
                                                                                         Boolean overdue, LocalDateTime from,
                                                                                         LocalDateTime to) {
                                            List<Recommendation> recommendations = recommendationRepository.findByClientId(client.getId());
                                            return filterRecommendations(recommendations, completed, overdue, from, to);
                                        }

                                        public List<Recommendation> getOverdueRecommendations(Psychologist psychologist) {
                                            List<Client> clients = clientRepository.findByPsychologistId(psychologist.getId());
                                            List<Recommendation> allRecommendations = new ArrayList<>();

                                            for (Client client : clients) {
                                                List<Recommendation> clientRecs = recommendationRepository.findByClientId(client.getId());
                                                allRecommendations.addAll(clientRecs);
                                            }

                                            LocalDateTime now = LocalDateTime.now();
                                            return allRecommendations.stream()
                                                    .filter(r -> !r.isCompleted() && r.getDeadline() != null && r.getDeadline().isBefore(now))
                                                    .sorted((r1, r2) -> r1.getDeadline().compareTo(r2.getDeadline()))
                                                    .collect(Collectors.toList());
                                        }

                                        public RecommendationStats getRecommendationStats(Psychologist psychologist) {
                                            List<Client> clients = clientRepository.findByPsychologistId(psychologist.getId());
                                            List<Recommendation> allRecommendations = new ArrayList<>();

                                            for (Client client : clients) {
                                                allRecommendations.addAll(recommendationRepository.findByClientId(client.getId()));
                                            }

                                            RecommendationStats stats = new RecommendationStats();
                                            stats.setTotalRecommendations(allRecommendations.size());

                                            long completed = allRecommendations.stream().filter(Recommendation::isCompleted).count();
                                            stats.setCompletedRecommendations(completed);

                                            long pending = allRecommendations.size() - completed;
                                            stats.setPendingRecommendations(pending);

                                            LocalDateTime now = LocalDateTime.now();
                                            long overdue = allRecommendations.stream()
                                                    .filter(r -> !r.isCompleted() && r.getDeadline() != null && r.getDeadline().isBefore(now))
                                                    .count();
                                            stats.setOverdueRecommendations(overdue);

                                            stats.setCompletionRate(allRecommendations.isEmpty() ? 0 : (double) completed / allRecommendations.size() * 100);

                                            return stats;
                                        }

                                        private List<Recommendation> filterRecommendations(List<Recommendation> recommendations,
                                                                                           Boolean completed, Boolean overdue,
                                                                                           LocalDateTime from, LocalDateTime to) {
                                            return recommendations.stream()
                                                    .filter(r -> completed == null || r.isCompleted() == completed)
                                                    .filter(r -> {
                                                        if (overdue == null) return true;
                                                        LocalDateTime now = LocalDateTime.now();
                                                        if (overdue) {
                                                            return !r.isCompleted() && r.getDeadline() != null && r.getDeadline().isBefore(now);
                                                        } else {
                                                            return r.isCompleted() || r.getDeadline() == null || !r.getDeadline().isBefore(now);
                                                        }
                                                    })
                                                    .filter(r -> from == null || (r.getCreatedAt() != null && !r.getCreatedAt().isBefore(from)))
                                                    .filter(r -> to == null || (r.getCreatedAt() != null && !r.getCreatedAt().isAfter(to)))
                                                    .sorted((r1, r2) -> {
                                                        // Сначала просроченные, затем по приоритету, затем по дедлайну
                                                        LocalDateTime now = LocalDateTime.now();
                                                        boolean r1Overdue = !r1.isCompleted() && r1.getDeadline() != null && r1.getDeadline().isBefore(now);
                                                        boolean r2Overdue = !r2.isCompleted() && r2.getDeadline() != null && r2.getDeadline().isBefore(now);

                                                        if (r1Overdue && !r2Overdue) return -1;
                                                        if (!r1Overdue && r2Overdue) return 1;

                                                        int priorityCompare = Integer.compare(r2.getPriority(), r1.getPriority());
                                                        if (priorityCompare != 0) return priorityCompare;

                                                        if (r1.getDeadline() == null && r2.getDeadline() == null) return 0;
                                                        if (r1.getDeadline() == null) return 1;
                                                        if (r2.getDeadline() == null) return -1;

                                                        return r1.getDeadline().compareTo(r2.getDeadline());
                                                    })
                                                    .collect(Collectors.toList());
                                        }

                                        @Transactional
                                        public void checkAndNotifyOverdue() {
                                            LocalDateTime now = LocalDateTime.now();
                                            LocalDateTime yesterday = now.minusDays(1);

                                            List<Recommendation> overdueRecommendations = recommendationRepository.findOverdueRecommendations(yesterday);

                                            for (Recommendation recommendation : overdueRecommendations) {
                                                // Отправляем уведомление клиенту
                                                notificationService.createNotification(
                                                        recommendation.getClient(),
                                                        com.psychology.model.entity.Notification.NotificationType.SYSTEM_ANNOUNCEMENT,
                                                        "Просроченная рекомендация",
                                                        String.format("Рекомендация '%s' просрочена", recommendation.getTitle())
                                                );
                                            }
                                        }
                                    }package com.psychology.service;

                                     import com.psychology.model.entity.Session;
                                     import com.psychology.model.entity.Psychologist;
                                     import com.psychology.model.entity.Client;
                                     import com.psychology.repository.SessionRepository;
                                     import com.psychology.repository.ClientRepository;
                                     import lombok.Data;
                                     import lombok.RequiredArgsConstructor;
                                     import org.springframework.stereotype.Service;
                                     import org.springframework.transaction.annotation.Transactional;

                                     import java.time.LocalDateTime;
                                     import java.util.List;

                                     @Service
                                     @RequiredArgsConstructor
                                     public class SessionService {

                                         private final SessionRepository sessionRepository;
                                         private final ClientRepository clientRepository;

                                         @Transactional
                                         public Session createSession(Psychologist psychologist, SessionRequest request) {
                                             Client client = clientRepository.findById(request.getClientId())
                                                     .orElseThrow(() -> new RuntimeException("Client not found"));

                                             // Проверяем, что клиент принадлежит психологу
                                             if (!client.getPsychologist().getId().equals(psychologist.getId())) {
                                                 throw new RuntimeException("Client does not belong to this psychologist");
                                             }

                                             // Проверяем, что время сеанса в будущем
                                             if (request.getScheduledAt().isBefore(LocalDateTime.now())) {
                                                 throw new RuntimeException("Session time must be in the future");
                                             }

                                             Session session = new Session();
                                             session.setPsychologist(psychologist);
                                             session.setClient(client);
                                             session.setScheduledAt(request.getScheduledAt());
                                             session.setDurationMinutes(request.getDurationMinutes());
                                             session.setDescription(request.getDescription());
                                             session.setStatus(Session.SessionStatus.SCHEDULED);

                                             return sessionRepository.save(session);
                                         }

                                         @Transactional
                                         public Session updateSession(Long sessionId, Psychologist psychologist, SessionUpdateRequest request) {
                                             Session session = sessionRepository.findById(sessionId)
                                                     .orElseThrow(() -> new RuntimeException("Session not found"));

                                             // Проверяем, что сеанс принадлежит психологу
                                             if (!session.getPsychologist().getId().equals(psychologist.getId())) {
                                                 throw new RuntimeException("Session does not belong to this psychologist");
                                             }

                                             if (request.getScheduledAt() != null) {
                                                 // Проверяем, что время сеанса в будущем
                                                 if (request.getScheduledAt().isBefore(LocalDateTime.now())) {
                                                     throw new RuntimeException("Session time must be in the future");
                                                 }
                                                 session.setScheduledAt(request.getScheduledAt());
                                             }
                                             if (request.getDurationMinutes() != null) {
                                                 session.setDurationMinutes(request.getDurationMinutes());
                                             }
                                             if (request.getDescription() != null) {
                                                 session.setDescription(request.getDescription());
                                             }
                                             if (request.getStatus() != null) {
                                                 session.setStatus(request.getStatus());
                                             }

                                             return sessionRepository.save(session);
                                         }

                                         public List<Session> getPsychologistSessions(Psychologist psychologist, LocalDateTime from, LocalDateTime to) {
                                             if (from != null && to != null) {
                                                 return sessionRepository.findByPsychologistIdAndScheduledAtBetween(
                                                         psychologist.getId(), from, to);
                                             }
                                             return sessionRepository.findByPsychologistIdOrderByScheduledAtDesc(psychologist.getId());
                                         }

                                         public List<Session> getClientSessions(Client client, LocalDateTime from, LocalDateTime to) {
                                             if (from != null && to != null) {
                                                 return sessionRepository.findByClientIdAndScheduledAtBetween(client.getId(), from, to);
                                             }
                                             return sessionRepository.findByClientIdOrderByScheduledAtDesc(client.getId());
                                         }

                                         @Transactional
                                         public Session cancelSession(Long sessionId, String userType, Object user) {
                                             Session session = sessionRepository.findById(sessionId)
                                                     .orElseThrow(() -> new RuntimeException("Session not found"));

                                             // Проверяем, что сеанс можно отменить
                                             if (session.getStatus() != Session.SessionStatus.SCHEDULED &&
                                                     session.getStatus() != Session.SessionStatus.CONFIRMED) {
                                                 throw new RuntimeException("Cannot cancel session in status: " + session.getStatus());
                                             }

                                             LocalDateTime now = LocalDateTime.now();
                                             LocalDateTime sessionTime = session.getScheduledAt();

                                             if (userType.equals("PSYCHOLOGIST")) {
                                                 Psychologist psychologist = (Psychologist) user;
                                                 if (!session.getPsychologist().getId().equals(psychologist.getId())) {
                                                     throw new RuntimeException("Session does not belong to this psychologist");
                                                 }
                                                 // Психолог может отменить в любое время
                                                 session.setStatus(Session.SessionStatus.CANCELLED);
                                             } else if (userType.equals("CLIENT")) {
                                                 Client client = (Client) user;
                                                 if (!session.getClient().getId().equals(client.getId())) {
                                                     throw new RuntimeException("Session does not belong to this client");
                                                 }
                                                 // Клиент может отменить не позднее чем за 12 часов до начала
                                                 if (sessionTime.minusHours(12).isBefore(now)) {
                                                     throw new RuntimeException("Cannot cancel session less than 12 hours before start");
                                                 }
                                                 session.setStatus(Session.SessionStatus.CANCELLED);
                                             } else {
                                                 throw new RuntimeException("Invalid user type");
                                             }

                                             return sessionRepository.save(session);
                                         }

                                         @Data
                                         public static class SessionRequest {
                                             private Long clientId;
                                             private LocalDateTime scheduledAt;
                                             private Integer durationMinutes = 50;
                                             private String description;
                                         }

                                         @Data
                                         public static class SessionUpdateRequest {
                                             private LocalDateTime scheduledAt;
                                             private Integer durationMinutes;
                                             private String description;
                                             private Session.SessionStatus status;
                                         }
                                     }package com.psychology.websocket;

                                      import lombok.extern.slf4j.Slf4j;
                                      import org.springframework.messaging.handler.annotation.MessageMapping;
                                      import org.springframework.messaging.handler.annotation.Payload;
                                      import org.springframework.messaging.simp.SimpMessagingTemplate;
                                      import org.springframework.stereotype.Controller;

                                      @Controller
                                      @Slf4j
                                      public class SimpleWebSocketController {

                                          private final SimpMessagingTemplate messagingTemplate;

                                          public SimpleWebSocketController(SimpMessagingTemplate messagingTemplate) {
                                              this.messagingTemplate = messagingTemplate;
                                          }

                                          @MessageMapping("/chat.test")
                                          public void testMessage(@Payload String message) {
                                              log.info("Received test message: {}", message);
                                              messagingTemplate.convertAndSend("/topic/test", "Echo: " + message);
                                          }
                                      }package com.psychology.websocket;

                                       import com.psychology.dto.ChatDTO;
                                       import com.psychology.dto.TypingNotificationDTO;
                                       import com.psychology.model.entity.User;
                                       import com.psychology.service.ChatService;
                                       import com.psychology.service.NotificationService;
                                       import lombok.Data;
                                       import lombok.RequiredArgsConstructor;
                                       import lombok.extern.slf4j.Slf4j;
                                       import org.springframework.messaging.handler.annotation.MessageMapping;
                                       import org.springframework.messaging.handler.annotation.Payload;
                                       import org.springframework.messaging.simp.SimpMessagingTemplate;
                                       import org.springframework.security.core.Authentication;
                                       import org.springframework.stereotype.Controller;

                                       @Controller
                                       @RequiredArgsConstructor
                                       @Slf4j
                                       public class WebSocketChatController {

                                           private final ChatService chatService;
                                           private final NotificationService notificationService;
                                           private final SimpMessagingTemplate messagingTemplate;

                                           @MessageMapping("/chat.send")
                                           public void sendMessage(@Payload ChatDTO.SendMessageRequest request,
                                                                   Authentication authentication) {
                                               try {
                                                   log.info("WebSocket send message from {}", authentication.getName());

                                                   User sender = (User) authentication.getPrincipal();
                                                   ChatDTO.MessageResponse response = chatService.sendMessage(sender, request);

                                                   // Отправляем сообщение получателю
                                                   String receiverDestination = "/user/" + request.getReceiverId() + "/queue/messages";
                                                   messagingTemplate.convertAndSend(receiverDestination, response);

                                                   // Отправляем подтверждение отправителю
                                                   String senderDestination = "/user/" + sender.getId() + "/queue/messages";
                                                   messagingTemplate.convertAndSend(senderDestination, response);

                                                   // Отправляем уведомление через NotificationService
                                                   notificationService.sendNewMessageNotification(response);

                                               } catch (Exception e) {
                                                   log.error("Error sending message via WebSocket: {}", e.getMessage());
                                               }
                                           }

                                           @MessageMapping("/chat.typing")
                                           public void typingNotification(@Payload TypingRequest request,
                                                                          Authentication authentication) {
                                               try {
                                                   User sender = (User) authentication.getPrincipal();
                                                   notificationService.sendTypingNotification(
                                                           sender.getId(),
                                                           request.getReceiverId(),
                                                           request.isTyping()
                                                   );

                                               } catch (Exception e) {
                                                   log.error("Error sending typing notification: {}", e.getMessage());
                                               }
                                           }

                                           @MessageMapping("/chat.read")
                                           public void markAsRead(@Payload ChatDTO.MarkAsReadRequest request,
                                                                  Authentication authentication) {
                                               try {
                                                   User user = (User) authentication.getPrincipal();
                                                   chatService.markAsRead(user, request.getMessageId());

                                                   // Уведомляем отправителя о прочтении через NotificationService
                                                   notificationService.sendMessageReadNotification(request.getMessageId(), user.getId());

                                               } catch (Exception e) {
                                                   log.error("Error marking message as read: {}", e.getMessage());
                                               }
                                           }

                                           @Data
                                           public static class TypingRequest {
                                               private Long receiverId;
                                               private boolean typing;
                                           }
                                       }
databaseChangeLog:
    - changeSet:
        id: 1
        author: psychology
        changes:
          - createTable:
              tableName: users
              columns:
                - column:
                    name: id
                    type: BIGINT
                    autoIncrement: true
                    constraints:
                      primaryKey: true
                      nullable: false
                - column:
                    name: phone
                    type: VARCHAR(20)
                    constraints:
                      unique: true
                      nullable: false
                - column:
                    name: role
                    type: VARCHAR(50)
                    constraints:
                      nullable: false
                - column:
                    name: created_at
                    type: TIMESTAMP
                    defaultValueComputed: CURRENT_TIMESTAMP
                - column:
                    name: updated_at
                    type: TIMESTAMP
                    defaultValueComputed: CURRENT_TIMESTAMP

          - createTable:
              tableName: psychologists
              columns:
                - column:
                    name: id
                    type: BIGINT
                    constraints:
                      primaryKey: true
                      nullable: false
                      foreignKeyName: fk_psychologist_user
                      references: users(id)
                - column:
                    name: full_name
                    type: VARCHAR(100)
                    constraints:
                      nullable: false
                - column:
                    name: email
                    type: VARCHAR(100)
                    constraints:
                      nullable: false
                - column:
                    name: education
                    type: TEXT
                - column:
                    name: specialization
                    type: VARCHAR(200)
                - column:
                    name: description
                    type: TEXT
                - column:
                    name: photo_url
                    type: VARCHAR(500)
                - column:
                    name: verified
                    type: BOOLEAN
                    defaultValueBoolean: false
                - column:
                    name: verified_at
                    type: TIMESTAMP

          - createTable:
              tableName: clients
              columns:
                - column:
                    name: id
                    type: BIGINT
                    constraints:
                      primaryKey: true
                      nullable: false
                      foreignKeyName: fk_client_user
                      references: users(id)
                - column:
                    name: full_name
                    type: VARCHAR(100)
                    constraints:
                      nullable: false
                - column:
                    name: age
                    type: INTEGER
                - column:
                    name: photo_url
                    type: VARCHAR(500)
                - column:
                    name: psychologist_id
                    type: BIGINT
                    constraints:
                      nullable: false
                      foreignKeyName: fk_client_psychologist
                      references: psychologists(id)
                - column:
                    name: linked_at
                    type: TIMESTAMP
                    defaultValueComputed: CURRENT_TIMESTAMP

          - createTable:
              tableName: invites
              columns:
                - column:
                    name: id
                    type: BIGINT
                    autoIncrement: true
                    constraints:
                      primaryKey: true
                      nullable: false
                - column:
                    name: token
                    type: VARCHAR(100)
                    constraints:
                      unique: true
                      nullable: false
                - column:
                    name: psychologist_id
                    type: BIGINT
                    constraints:
                      nullable: false
                      foreignKeyName: fk_invite_psychologist
                      references: psychologists(id)
                - column:
                    name: created_at
                    type: TIMESTAMP
                    defaultValueComputed: CURRENT_TIMESTAMP
                - column:
                    name: expires_at
                    type: TIMESTAMP
                - column:
                    name: used
                    type: BOOLEAN
                    defaultValueBoolean: false
                - column:
                    name: used_at
                    type: TIMESTAMP

          - createIndex:
              tableName: users
              columns:
                - column:
                    name: phone
              indexName: idx_users_phone

          - createIndex:
              tableName: psychologists
              columns:
                - column:
                    name: email
              indexName: idx_psychologists_email

          - createIndex:
              tableName: invites
              columns:
                - column:
                    name: token
              indexName: idx_invites_token
 databaseChangeLog:
   - include:
       file: db/changelog/changes/001-initial-schema.yaml
 # Server
# Server
server.port=8080
#server.servlet.context-path=/api

# Database (PostgreSQL)
spring.datasource.url=jdbc:postgresql://localhost:5432/psychology_db
spring.datasource.username=psychology_user
spring.datasource.password=psychology_pass
spring.datasource.driver-class-name=org.postgresql.Driver

# JPA
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect

# ??????? ??????????? SQL ? ???????????
spring.jpa.properties.hibernate.show_sql=true
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.properties.hibernate.use_sql_comments=true

# ??????????? ????????
logging.level.org.hibernate.SQL=DEBUG
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE
spring.jpa.properties.hibernate.jdbc.lob.non_contextual_creation=true

# ????????? ????????? ????, ????? ?? ???????????
logging.level.org.hibernate.orm.jdbc.bind=TRACE
logging.level.org.springframework.boot.autoconfigure=ERROR
# Redis
spring.data.redis.host=localhost
spring.data.redis.port=6379
spring.data.redis.timeout=60000

# JWT
jwt.secret=mySuperSecretKeyForJWTGenerationWithAtLeast256BitsLengthToBeSecureEnough
# 30 ?????
jwt.access-expiration=1800000
# 7 ????
jwt.refresh-expiration=604800000

# ???????? ????????? ??? ??????
file.upload-dir=uploads
spring.servlet.multipart.max-file-size=5MB
spring.servlet.multipart.max-request-size=10MB

# Logging
logging.level.com.psychology=DEBUG
logging.level.org.springframework.security=DEBUG
logging.level.org.springframework.web=DEBUG
logging.level.org.springframework.messaging=DEBUG

# Tomcat
server.tomcat.max-threads=200
server.tomcat.min-spare-threads=10
server.tomcat.connection-timeout=60000

# ????????? open-in-view ????? ?????????????? ??????
spring.jpa.open-in-view=false
# ????????? ????????? ??????? ????????
spring.jackson.serialization.fail-on-empty-beans=false

logging.level.org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter=ERROR
logging.level.org.springframework.web.servlet.FrameworkServlet=WARN

# ???????? ??????? ???????? ??? ?????????? (???????? ??? ????????????)
spring.jpa.properties.hibernate.enable_lazy_load_no_trans=true

# ???????? ??????????? ?????
spring.task.scheduling.enabled=true
spring.task.scheduling.pool.size=5

# ????????? ??? ????????????
scheduler.session-reminder.enabled=true
scheduler.cleanup.enabled=true

 <?xml version="1.0" encoding="UTF-8"?>
 <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
     <modelVersion>4.0.0</modelVersion>
     <parent>
         <groupId>org.springframework.boot</groupId>
         <artifactId>spring-boot-starter-parent</artifactId>
         <version>4.0.2</version>
         <relativePath/> <!-- lookup parent from repository -->
     </parent>
     <groupId>com.psychology</groupId>
     <artifactId>psychology</artifactId>
     <version>0.0.1-SNAPSHOT</version>
     <name>psychology</name>
     <description>psychology</description>
     <url/>
     <licenses>
         <license/>
     </licenses>
     <developers>
         <developer/>
     </developers>
     <scm>
         <connection/>
         <developerConnection/>
         <tag/>
         <url/>
     </scm>
     <properties>
         <java.version>21</java.version>
     </properties>
     <!-- Обновляем версии зависимостей -->
     <dependencies>
         <!-- Spring Boot Starters -->
         <dependency>
             <groupId>org.springframework.boot</groupId>
             <artifactId>spring-boot-starter-web</artifactId>
         </dependency>
         <dependency>
             <groupId>org.springframework.boot</groupId>
             <artifactId>spring-boot-starter-security</artifactId>
         </dependency>
         <dependency>
             <groupId>org.springframework.boot</groupId>
             <artifactId>spring-boot-starter-data-jpa</artifactId>
         </dependency>
         <dependency>
             <groupId>org.springframework.boot</groupId>
             <artifactId>spring-boot-starter-data-redis</artifactId>
         </dependency>
         <!-- WebSocket -->
         <dependency>
             <groupId>org.springframework.boot</groupId>
             <artifactId>spring-boot-starter-websocket</artifactId>
         </dependency>
         <dependency>
             <groupId>org.webjars</groupId>
             <artifactId>webjars-locator-core</artifactId>
         </dependency>
         <dependency>
             <groupId>org.webjars</groupId>
             <artifactId>sockjs-client</artifactId>
             <version>1.5.1</version>
         </dependency>
         <dependency>
             <groupId>org.webjars</groupId>
             <artifactId>stomp-websocket</artifactId>
             <version>2.3.4</version>
         </dependency>
         <dependency>
             <groupId>org.springframework.boot</groupId>
             <artifactId>spring-boot-starter-validation</artifactId>
         </dependency>

         <!-- Database -->
         <dependency>
             <groupId>org.postgresql</groupId>
             <artifactId>postgresql</artifactId>
             <scope>runtime</scope>
         </dependency>

         <!-- JWT (обновленная версия) -->
         <dependency>
             <groupId>io.jsonwebtoken</groupId>
             <artifactId>jjwt-api</artifactId>
             <version>0.11.5</version>
         </dependency>
         <dependency>
             <groupId>io.jsonwebtoken</groupId>
             <artifactId>jjwt-impl</artifactId>
             <version>0.11.5</version>
             <scope>runtime</scope>
         </dependency>
         <dependency>
             <groupId>io.jsonwebtoken</groupId>
             <artifactId>jjwt-jackson</artifactId>
             <version>0.11.5</version>
             <scope>runtime</scope>
         </dependency>

         <!-- Utils -->
         <dependency>
             <groupId>org.projectlombok</groupId>
             <artifactId>lombok</artifactId>
             <optional>true</optional>
         </dependency>

         <!-- Apache Commons Lang -->
         <dependency>
             <groupId>org.apache.commons</groupId>
             <artifactId>commons-lang3</artifactId>
             <version>3.12.0</version>
         </dependency>

         <!-- Testing -->
         <dependency>
             <groupId>org.springframework.boot</groupId>
             <artifactId>spring-boot-starter-test</artifactId>
             <scope>test</scope>
         </dependency>
     </dependencies>

     <build>
         <plugins>
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-compiler-plugin</artifactId>
                 <configuration>
                     <annotationProcessorPaths>
                         <path>
                             <groupId>org.projectlombok</groupId>
                             <artifactId>lombok</artifactId>
                         </path>
                     </annotationProcessorPaths>
                 </configuration>
             </plugin>
             <plugin>
                 <groupId>org.springframework.boot</groupId>
                 <artifactId>spring-boot-maven-plugin</artifactId>
                 <configuration>
                     <excludes>
                         <exclude>
                             <groupId>org.projectlombok</groupId>
                             <artifactId>lombok</artifactId>
                         </exclude>
                     </excludes>
                 </configuration>
             </plugin>
         </plugins>
     </build>

 </project>
Привет нужно написать бэкенд по этому Тз
Техническое задание: Веб-сервис для онлайн-работы психолога с клиентами
1. Общая концепция
Веб-сервис предназначен для безопасного и конфиденциального взаимодействия психолога и его клиентов. Ключевые принципы:

Безопасность: минимизация хранения чувствительных данных, шифрование

Простота: интуитивный интерфейс, минималистичный дизайн

Конфиденциальность: строгое разграничение доступа между клиентами и психологами

Мобильность: адаптивный дизайн для работы с любых устройств

Отличительная особенность регистрации:

Клиент: может зарегистрироваться ТОЛЬКО по пригласительной ссылке от психолога

Психолог: регистрируется самостоятельно по номеру телефона через публичную форму

2. Роли в системе
2.1 Клиент
Пользователь, получивший доступ к платформе исключительно по пригласительной ссылке психолога. После регистрации автоматически привязывается к пригласившему психологу.

2.2 Психолог
Специалист, который самостоятельно регистрируется в системе. Функционал:

Управление клиентами

Назначение сеансов

Ведение рекомендаций и заметок

Общение с клиентами

Ведение дневника наблюдений

3. Регистрация и авторизация
3.1 Общий принцип
В системе отсутствуют логины и пароли

Авторизация осуществляется по номеру телефона + одноразовый код (OTP)

Используется JWT для авторизации и Redis для временных данных

3.2 Регистрация психолога
Процесс регистрации:

Психолог переходит на публичную страницу регистрации

Вводит номер телефона

Получает одноразовый код (4-6 цифр) по SMS (в логах на этапе разработки)

Вводит код для подтверждения

Заполняет расширенный профиль:

ФИО (обязательно)

Контактный email (обязательно)

Образование и квалификация (текстовое поле)

Специализация (выбор из списка или теги)

Краткое описание о себе

Фото (опционально)

Согласие с правилами платформы и этическим кодексом

Профиль отправляется на ручную верификацию администратором

После верификации психолог получает полный доступ к функционалу

3.3 Пригласительные ссылки (для клиентов)
Создание:

Психолог может создавать пригласительные ссылки из своего ЛК

Ссылка содержит уникальный токен

Параметры ссылки:

Одноразовая

Срок действия: 7 дней

Привязана к конкретному психологу

Использование:

Клиент переходит по пригласительной ссылке

Система проверяет валидность токена

Клиенту предлагается ввести номер телефона

Далее процесс аналогичен OTP-авторизации

ВАЖНО: Клиент не может зарегистрироваться без действующей пригласительной ссылки от психолога.

3.4 Вход по номеру телефона
Пользователь вводит номер телефона

Генерируется одноразовый код (4-6 цифр)

Код:

Сохраняется в Redis

TTL: 5 минут

Привязан к номеру телефона

Код отправляется пользователю (на этапе разработки — вывод в логи)

Пользователь вводит код

При успехе:

Создаётся пользователь (если новый)

Создаётся JWT-токен

Пользователь авторизуется в системе

3.5 Защита от перебора OTP
Максимум 3 попытки ввода OTP с одного номера телефона

Блокировка повторной отправки OTP: 1 минута после предыдущей отправки

Автоматическая блокировка номера после 5 неудачных попыток авторизации в течение часа

Rate-limiting: не более 10 запросов авторизации в минуту с одного IP

4. Профили пользователей
4.1 Профиль клиента
После первого входа по пригласительной ссылке клиенту предлагается заполнить профиль:

ФИО (обязательно)

Возраст (обязательно)

Фото (опционально)

После заполнения:

Клиент автоматически привязывается к пригласившему психологу

Попадает в личный кабинет

Получает доступ ко всему функционалу для клиентов

4.2 Профиль психолога
После верификации администратором психолог может:

Редактировать профиль (ФИО, фото, описание, специализация)

Просматривать свой публичный профиль (как его видят клиенты)

Настраивать уведомления

Видеть статистику: количество активных клиентов, проведенных сеансов

5. Функционал клиента
5.1 Главный экран
Информация о психологе (ФИО, фото, специализация)

Ближайший сеанс (дата, время, статус)

Быстрый доступ к чату

Счетчик непрочитанных сообщений

Уведомления о новых событиях

5.2 Чат с психологом
Текстовый чат в реальном времени (WebSocket)

История сообщений

Доступен только между клиентом и его психологом

Поддержка файлов (изображения, PDF) до 5MB

Ограничение длины сообщения: 2000 символов

Звонки: опционально, кнопка может быть реализована как заглушка с описанием "Видеозвонки в разработке" или WebRTC в будущем.

5.3 Расписание сеансов
Список будущих сеансов с возможностью подтверждения

История прошедших сеансов:

Дата и время

Длительность

Статус (проведён / отменён / перенесен)

Уведомления за 24 часа и 1 час до начала сеанса

5.4 Дневник клиента
Клиент может создавать записи:

Дата (автоматически)

Текст (мысли, переживания, события)

Теги/категории (опционально)

Ограничение длины записи: 5000 символов

Записи доступны:

Клиенту (полный доступ)

Его психологу (только просмотр)

Возможность редактирования и удаления записей клиентом

5.5 Рекомендации специалиста
Список рекомендаций от психолога

Рекомендации включают:

Описание

Период действия

Статус (актуальна / завершена)

Клиент видит только актуальные и прошлые рекомендации

Фильтрация по статусу и дате

5.6 Уведомления
Push-уведомления в браузере (при согласии)

Внутрисервисные уведомления

Типы уведомлений:

Новое сообщение в чате

Назначен новый сеанс

Напоминание о сеансе (за 24 часа и 1 час)

Отмена или перенос сеанса

Новая рекомендация от психолога

Напоминание о заполнении дневника (настраивается психологом)

6. Функционал психолога
6.1 Дашборд
Список ближайших сеансов (сегодня/завтра):

Дата и время

Клиент (ФИО, фото)

Статус сеанса

Общее количество клиентов

Статистика за текущий месяц:

Проведено сеансов

Запланировано сеансов

Новые клиенты

Быстрые действия: создать сеанс, написать клиенту

6.2 Управление клиентами
Список всех клиентов с поиском и фильтрацией

Карточка клиента содержит:

Профиль клиента (ФИО, возраст, фото)

Историю сеансов

Дневник клиента (только просмотр)

Рекомендации (история и активные)

Создание пригласительных ссылок для новых клиентов

6.3 Управление сеансами
Статусы сеанса:

Запланирован - сеанс создан, ожидает проведения

Подтвержден - клиент подтвердил участие

В процессе - сеанс начался (для будущей интеграции)

Завершен - сеанс проведен успешно

Отменен - сеанс отменен одной из сторон

Перенесен - сеанс перенесен на другое время

Создание сеанса:

Выбор клиента из списка

Выбор даты и времени

Указание длительности (по умолчанию 50 минут)

Добавление описания/заметок (опционально)

Правила отмены/переноса:

Психолог может отменить или перенести сеанс в любое время

Клиент может отменить сеанс не позднее чем за 12 часов до начала

При отмене сеанса вторая сторона получает уведомление

При переносе создается новая запись о сеансе, старая помечается как "Перенесен"

6.4 Рекомендации
Психолог может:

Добавлять рекомендации клиенту

Редактировать активные рекомендации

Завершать (помечать как неактуальные)

Просматривать историю всех рекомендаций

Шаблоны рекомендаций для быстрого создания

6.5 Чат с клиентами
Единый интерфейс для общения со всеми клиентами

Список диалогов с последними сообщениями

Поиск по истории сообщений

Индикатор непрочитанных сообщений

Возможность прикреплять файлы к сообщениям

6.6 Статистика и отчеты
Количество сеансов за период

Активность клиентов (посещаемость, записи в дневнике)

Общая нагрузка (часов в неделю/месяц)

Экспорт данных в CSV для личного учета

7. Безопасность и ограничения доступа
7.1 Разграничение прав
Клиент имеет доступ только к своим данным

Психолог имеет доступ только к данным своих клиентов

Администратор имеет доступ к верификации психологов и технической поддержке

7.2 Защита данных
JWT для авторизации

Redis для хранения:

OTP кодов

Токенов приглашений

Blacklist токенов

Сессионных данных

Защита от:

Перебора OTP

Повторного использования invite-ссылок

XSS и CSRF атак

7.3 Управление JWT токенами
Access Token: срок жизни 30 минут

Refresh Token: срок жизни 7 дней, хранится в HttpOnly cookie

Механизм обновления:

При истечении Access Token фронтенд использует Refresh Token

Refresh Token одноразовый

При выходе из системы токены попадают в blacklist

Инвалидация всех токенов при смене номера телефона

7.4 Защита персональных данных
Шифрование чувствительных данных (номера телефонов) с использованием AES-256

Автоматическое удаление записей дневника старше 3 лет (настраиваемо)

История чатов хранится 2 года, затем анонимизируется

Экспорт всех пользовательских данных в формате JSON

Полное удаление аккаунта по запросу пользователя (GDPR compliance)

7.5 Rate limiting
100 запросов в минуту на аутентифицированные эндпоинты

10 запросов в минуту на публичные эндпоинты

Отдельные лимиты для OTP и регистрации

8. Технические ограничения и упрощения
Для MVP:
❌ Без платежных систем
❌ Без мобильного приложения (только веб)
❌ Без сложной видеосвязи (WebRTC)
❌ Без групповых сеансов или чатов
❌ Без сложной аналитики и AI-рекомендаций

✅ Акцент на backend-логику, безопасность и роли
✅ Внутренние уведомления (без SMS/email на MVP)
✅ Простой календарь (без выбора слотов, ручной ввод)
✅ Базовый поиск и фильтрация

Технические ограничения:
Максимальный размер файла: 5MB

Максимальное количество клиентов у психолога: 50

Максимальная длина сообщений: 2000 символов

Хранение файлов: локальное или S3-совместимое

9. Технологический стек
Backend:
Java 17+

Spring Boot 3.x

Spring Security с JWT

Spring Data JPA для работы с БД

Spring WebSocket для чата

Redis для кэша, сессий и OTP

PostgreSQL (основная БД) / SQLite (для разработки)

JUnit 5, Mockito для тестирования

Liquibase/Flyway для миграций

Frontend (рекомендуемый):
React 18+ или Vue 3

TypeScript

Vite как сборщик

Tailwind CSS для стилей

Axios для HTTP-запросов

Socket.io-client или STOMP для WebSocket

React Router / Vue Router для навигации

Инфраструктура:
Docker для контейнеризации

Docker Compose для локальной разработки

GitHub Actions / GitLab CI для CI/CD

Nginx как reverse proxy

Let's Encrypt для HTTPS

10. API спецификация
10.1 Общие принципы:
RESTful API с JSON форматом

Версионирование в URL: /api/v1/

Стандартные HTTP коды ответов

Пагинация: limit и offset параметры

Фильтрация и сортировка через query-параметры

10.2 Основные группы эндпоинтов:
/api/v1/auth/** - авторизация, OTP, refresh токенов

/api/v1/profile/** - управление профилями

/api/v1/invites/** - работа с приглашениями (создание, валидация)

/api/v1/sessions/** - управление сеансами

/api/v1/chat/** - REST API для чата + WebSocket

/api/v1/journal/** - дневник клиента

/api/v1/recommendations/** - рекомендации

/api/v1/notifications/** - уведомления

/api/v1/admin/** - администрирование (верификация психологов)

10.3 WebSocket для чата:
Endpoint: /ws/chat

Протокол: STOMP over WebSocket

Авторизация через JWT в query-параметре

Topics:

/user/{userId}/queue/messages - личные сообщения

/topic/notifications - общие уведомления

11. Жизненный цикл данных
11.1 Время хранения:
OTP коды: 5 минут (Redis)

Invite-токены: 7 дней (Redis)

Blacklist токенов: 30 дней (Redis)

Сессионные данные: до 24 часов (Redis)

11.2 Автоматическая архивация:
Завершенные сеансы: через 30 дней → архив

Неактивные диалоги (6+ месяцев): сжатие

Удаленные аккаунты: полное удаление через 30 дней

11.3 Бэкапы:
Ежедневные инкрементальные бэкапы БД

Еженедельные полные бэкапы

Хранение бэкапов 90 дней

12. Разработка и деплой
12.1 Этапы разработки:
Phase 1: Базовая аутентификация + профили

Phase 2: Система приглашений + привязка клиентов

Phase 3: Чат + уведомления

Phase 4: Сеансы + расписание

Phase 5: Дневник + рекомендации

Phase 6: Статистика + админ-панель

12.2 Деплой:
Локальная разработка: Docker Compose

Staging: отдельный сервер/контейнер

Production: облачный хостинг (AWS/GCP) или VPS

12.3 Мониторинг:
Логирование в ELK Stack или аналоги

Мониторинг здоровья эндпоинтов

Трассировка запросов

Метрики производительности

13. Возможности для дальнейшего развития
Высокий приоритет:
SMS-шлюз для реальной отправки OTP

Email-уведомления

WebRTC звонки

Мобильное приложение (React Native/Flutter)

Средний приоритет:
Платежная система для оплаты сеансов

Групповые сеансы

Библиотека материалов (статьи, упражнения)

Система отзывов о психологах

Низкий приоритет:
AI-ассистент для анализа настроения

Интеграция с календарями (Google Calendar, Outlook)

Видеотранскрипция сеансов

Сертификаты и документооборот

14. Ключевые отличия регистрации
Для психолога:
Публичная страница регистрации

Ввод номера телефона → OTP

Заполнение расширенного профиля

Ручная верификация администратором

Полный доступ после верификации

Для клиента:
ТОЛЬКО через пригласительную ссылку психолога

Ввод номера телефона → OTP

Заполнение базового профиля (ФИО, возраст)

Автоматическая привязка к психологу

Немедленный доступ к функционалу


привет твоя задачу сравнить с ТЗ и сказать что уже полностью реализовано, что в работе и + что не сделано то надо сделать
наша задача полностью сделать бэкенд что бы перейти к созданию фронта скажи много ли ещё осталось?
